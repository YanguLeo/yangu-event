!function(t){var e={init:function(e){return this.each(function(){var a=t(this),i=a.data("monthpicker"),n=e&&e.year?e.year:(new Date).getFullYear(),s=t.extend({pattern:"mm/yyyy",selectedMonth:null,selectedMonthName:"",selectedYear:n,startYear:n-10,finalYear:n+10,monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],id:"monthpicker_"+(Math.random()*Math.random()).toString().replace(".",""),openOnFocus:!0,disabledMonths:[]},e);s.dateSeparator=s.pattern.replace(/(mmm|mm|m|yyyy|yy|y)/gi,""),i||(t(this).data("monthpicker",{target:a,settings:s}),s.openOnFocus===!0&&a.on("focus",function(){a.monthpicker("show")}),a.monthpicker("parseInputValue",s),a.monthpicker("mountWidget",s),a.on("monthpicker-click-month",function(t,e,i){a.monthpicker("setValue",s),a.monthpicker("hide")}),a.addClass("mtz-monthpicker-widgetcontainer"),t(document).unbind("mousedown.mtzmonthpicker").on("mousedown.mtzmonthpicker",function(e){(!e.target.className||e.target.className.toString().indexOf("mtz-monthpicker")<0)&&t(this).monthpicker("hideAll")}))})},show:function(){t(this).monthpicker("hideAll");var e=t("#"+this.data("monthpicker").settings.id);e.css("top",this.offset().top+this.outerHeight()),t(window).width()>e.width()+this.offset().left?e.css("left",this.offset().left):e.css("left",this.offset().left-e.width()),e.show(),e.find("select").focus(),this.trigger("monthpicker-show")},hide:function(){var e=t("#"+this.data("monthpicker").settings.id);e.is(":visible")&&(e.hide(),this.trigger("monthpicker-hide"))},hideAll:function(){t(".mtz-monthpicker-widgetcontainer").each(function(){"undefined"!=typeof t(this).data("monthpicker")&&t(this).monthpicker("hide")})},setValue:function(t){var e=t.selectedMonth,a=t.selectedYear;t.pattern.indexOf("mmm")>=0?e=t.selectedMonthName:t.pattern.indexOf("mm")>=0&&t.selectedMonth<10&&(e="0"+t.selectedMonth),t.pattern.indexOf("yyyy")<0&&(a=a.toString().substr(2,2)),t.pattern.indexOf("y")>t.pattern.indexOf(t.dateSeparator)?this.val(e+t.dateSeparator+a):this.val(a+t.dateSeparator+e),this.change()},disableMonths:function(e){var a=this.data("monthpicker").settings,i=t("#"+a.id);a.disabledMonths=e,i.find(".mtz-monthpicker-month").each(function(){var a=parseInt(t(this).data("month"));t.inArray(a,e)>=0?t(this).addClass("ui-state-disabled"):t(this).removeClass("ui-state-disabled")})},mountWidget:function(e){var a=this,i=t('<div id="'+e.id+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all" />'),n=t('<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all mtz-monthpicker" />'),s=t('<select class="mtz-monthpicker mtz-monthpicker-year" />'),r=t('<table class="mtz-monthpicker" />'),o=t('<tbody class="mtz-monthpicker" />'),c=t('<tr class="mtz-monthpicker" />'),d="",h=(e.selectedYear,null),l=t(this).data("selected-year"),p=t(this).data("start-year"),m=t(this).data("final-year");l&&(e.selectedYear=l),p&&(e.startYear=p),m&&(e.finalYear=m),i.css({position:"absolute",zIndex:999999,whiteSpace:"nowrap",width:"250px",overflow:"hidden",textAlign:"center",display:"none",top:a.offset().top+a.outerHeight(),left:a.offset().left}),s.on("change",function(){var i=t(this).parent().parent().find("td[data-month]");i.removeClass("ui-state-active"),t(this).val()==e.selectedYear&&i.filter("td[data-month="+e.selectedMonth+"]").addClass("ui-state-active"),a.trigger("monthpicker-change-year",t(this).val())});for(var u=e.startYear;u<=e.finalYear;u++){var h=t('<option class="mtz-monthpicker" />').attr("value",u).append(u);e.selectedYear==u&&h.attr("selected","selected"),s.append(h)}n.append(s).appendTo(i);for(var u=1;12>=u;u++)d=t('<td class="ui-state-default mtz-monthpicker mtz-monthpicker-month" style="padding:5px;cursor:default;" />').attr("data-month",u),e.selectedMonth==u&&d.addClass("ui-state-active"),d.append(e.monthNames[u-1]),c.append(d).appendTo(o),u%3===0&&(c=t('<tr class="mtz-monthpicker" />'));o.find(".mtz-monthpicker-month").on("click",function(){var i=parseInt(t(this).data("month"));t.inArray(i,e.disabledMonths)<0&&(e.selectedYear=t(this).closest(".ui-datepicker").find(".mtz-monthpicker-year").first().val(),e.selectedMonth=t(this).data("month"),e.selectedMonthName=t(this).text(),a.trigger("monthpicker-click-month",t(this).data("month")),t(this).closest("table").find(".ui-state-active").removeClass("ui-state-active"),t(this).addClass("ui-state-active"))}),r.append(o).appendTo(i),i.appendTo("body")},destroy:function(){return this.each(function(){t(this).removeClass("mtz-monthpicker-widgetcontainer").unbind("focus").removeData("monthpicker")})},getDate:function(){var t=this.data("monthpicker").settings;return t.selectedMonth&&t.selectedYear?new Date(t.selectedYear,t.selectedMonth-1):null},parseInputValue:function(t){if(this.val()&&t.dateSeparator){var e=this.val().toString().split(t.dateSeparator);0===t.pattern.indexOf("m")?(t.selectedMonth=e[0],t.selectedYear=e[1]):(t.selectedMonth=e[1],t.selectedYear=e[0])}}};t.fn.monthpicker=function(a){return e[a]?e[a].apply(this,Array.prototype.slice.call(arguments,1)):"object"!=typeof a&&a?void t.error("Method "+a+" does not exist on jQuery.mtz.monthpicker"):e.init.apply(this,arguments)}}(jQuery);;
/**
 * Created by didokun on 04/08/16.
 */
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/maps/google_maps_api_v3.js
// ==/ClosureCompiler==

/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 * <br/>
 * This is a v3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >v2 MarkerClusterer</a>.
 */

/**
 * @license
 * Copyright 2010 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'averageCenter': (boolean) Whether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 *       'iconAnchor': (Array) The anchor position of the icon x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
function MarkerClusterer(map, opt_markers, opt_options) {
    // MarkerClusterer implements google.maps.OverlayView interface. We use the
    // extend function to extend MarkerClusterer with google.maps.OverlayView
    // because it might not always be available when the code is defined so we
    // look for it at the last possible moment. If it doesn't exist now then
    // there is no point going ahead :)
    this.extend(MarkerClusterer, google.maps.OverlayView);
    this.map_ = map;

    /**
     * @type {Array.<google.maps.Marker>}
     * @private
     */
    this.markers_ = [];

    /**
     *  @type {Array.<Cluster>}
     */
    this.clusters_ = [];

    this.sizes = [53, 56, 66, 78, 90];

    /**
     * @private
     */
    this.styles_ = [];

    /**
     * @type {boolean}
     * @private
     */
    this.ready_ = false;

    var options = opt_options || {};

    /**
     * @type {number}
     * @private
     */
    this.gridSize_ = options['gridSize'] || 60;

    /**
     * @private
     */
    this.minClusterSize_ = options['minimumClusterSize'] || 2;


    /**
     * @type {?number}
     * @private
     */
    this.maxZoom_ = options['maxZoom'] || null;

    this.styles_ = options['styles'] || [];

    /**
     * @type {string}
     * @private
     */
    this.imagePath_ = options['imagePath'] ||
        this.MARKER_CLUSTER_IMAGE_PATH_;

    /**
     * @type {string}
     * @private
     */
    this.imageExtension_ = options['imageExtension'] ||
        this.MARKER_CLUSTER_IMAGE_EXTENSION_;

    /**
     * @type {boolean}
     * @private
     */
    this.zoomOnClick_ = true;

    if (options['zoomOnClick'] != undefined) {
        this.zoomOnClick_ = options['zoomOnClick'];
    }

    /**
     * @type {boolean}
     * @private
     */
    this.averageCenter_ = false;

    if (options['averageCenter'] != undefined) {
        this.averageCenter_ = options['averageCenter'];
    }

    this.setupStyles_();

    this.setMap(map);

    /**
     * @type {number}
     * @private
     */
    this.prevZoom_ = this.map_.getZoom();

    // Add the map event listeners
    var that = this;
    google.maps.event.addListener(this.map_, 'zoom_changed', function() {
        var zoom = that.map_.getZoom();

        if (that.prevZoom_ != zoom) {
            that.prevZoom_ = zoom;
            that.resetViewport();
        }
    });

    google.maps.event.addListener(this.map_, 'idle', function() {
        that.redraw();
    });

    // Finally, add the markers
    if (opt_markers && opt_markers.length) {
        this.addMarkers(opt_markers, false);
    }
}


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
    return (function(object) {
        for (var property in object.prototype) {
            this.prototype[property] = object.prototype[property];
        }
        return this;
    }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
    this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function() {
    if (this.styles_.length) {
        return;
    }

    for (var i = 0, size; size = this.sizes[i]; i++) {
        this.styles_.push({
            url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
            height: size,
            width: size
        });
    }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
    var markers = this.getMarkers();
    var bounds = new google.maps.LatLngBounds();
    for (var i = 0, marker; marker = markers[i]; i++) {
        bounds.extend(marker.getPosition());
    }

    this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
    this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function() {
    return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function() {
    return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function() {
    return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function() {
    return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
    return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
    this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
    return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
    var index = 0;
    var count = markers.length;
    var dv = count;
    while (dv !== 0) {
        dv = parseInt(dv / 10, 10);
        index++;
    }

    index = Math.min(index, numStyles);
    return {
        text: count,
        index: index
    };
};


/**
 * Set the calculator function.
 *
 * @param {function(Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
    this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function(Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function() {
    return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
    for (var i = 0, marker; marker = markers[i]; i++) {
        this.pushMarkerTo_(marker);
    }
    if (!opt_nodraw) {
        this.redraw();
    }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
    marker.isAdded = false;
    if (marker['draggable']) {
        // If the marker is draggable add a listener so we update the clusters on
        // the drag end.
        var that = this;
        google.maps.event.addListener(marker, 'dragend', function() {
            marker.isAdded = false;
            that.repaint();
        });
    }
    this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
    this.pushMarkerTo_(marker);
    if (!opt_nodraw) {
        this.redraw();
    }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function(marker) {
    var index = -1;
    if (this.markers_.indexOf) {
        index = this.markers_.indexOf(marker);
    } else {
        for (var i = 0, m; m = this.markers_[i]; i++) {
            if (m == marker) {
                index = i;
                break;
            }
        }
    }

    if (index == -1) {
        // Marker is not in our list of markers.
        return false;
    }

    marker.setMap(null);

    this.markers_.splice(index, 1);

    return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
    var removed = this.removeMarker_(marker);

    if (!opt_nodraw && removed) {
        this.resetViewport();
        this.redraw();
        return true;
    } else {
        return false;
    }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
    var removed = false;

    for (var i = 0, marker; marker = markers[i]; i++) {
        var r = this.removeMarker_(marker);
        removed = removed || r;
    }

    if (!opt_nodraw && removed) {
        this.resetViewport();
        this.redraw();
        return true;
    }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function(ready) {
    if (!this.ready_) {
        this.ready_ = ready;
        this.createClusters_();
    }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
    return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function() {
    return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function(map) {
    this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
    return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(size) {
    this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function() {
    return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function(size) {
    this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
    var projection = this.getProjection();

    // Turn the bounds into latlng.
    var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
        bounds.getNorthEast().lng());
    var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
        bounds.getSouthWest().lng());

    // Convert the points to pixels and the extend out by the grid size.
    var trPix = projection.fromLatLngToDivPixel(tr);
    trPix.x += this.gridSize_;
    trPix.y -= this.gridSize_;

    var blPix = projection.fromLatLngToDivPixel(bl);
    blPix.x -= this.gridSize_;
    blPix.y += this.gridSize_;

    // Convert the pixel points back to LatLng
    var ne = projection.fromDivPixelToLatLng(trPix);
    var sw = projection.fromDivPixelToLatLng(blPix);

    // Extend the bounds to contain the new bounds.
    bounds.extend(ne);
    bounds.extend(sw);

    return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
    return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
    this.resetViewport(true);

    // Set the markers a empty array.
    this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function(opt_hide) {
    // Remove all the clusters
    for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
        cluster.remove();
    }

    // Reset the markers to not be added and to be invisible.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
        marker.isAdded = false;
        if (opt_hide) {
            marker.setMap(null);
        }
    }

    this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function() {
    var oldClusters = this.clusters_.slice();
    this.clusters_.length = 0;
    this.resetViewport();
    this.redraw();

    // Remove the old clusters.
    // Do it in a timeout so the other clusters have been drawn first.
    window.setTimeout(function() {
        for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
            cluster.remove();
        }
    }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function() {
    this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
 */
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
    if (!p1 || !p2) {
        return 0;
    }

    var R = 6371; // Radius of the Earth in km
    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c;
    return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
    var distance = 40000; // Some large number
    var clusterToAddTo = null;
    var pos = marker.getPosition();
    for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
        var center = cluster.getCenter();
        if (center) {
            var d = this.distanceBetweenPoints_(center, marker.getPosition());
            if (d < distance) {
                distance = d;
                clusterToAddTo = cluster;
            }
        }
    }

    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
        clusterToAddTo.addMarker(marker);
    } else {
        var cluster = new Cluster(this);
        cluster.addMarker(marker);
        this.clusters_.push(cluster);
    }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function() {
    if (!this.ready_) {
        return;
    }

    // Get our current map view bounds.
    // Create a new bounds object so we don't affect the map.
    var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
        this.map_.getBounds().getNorthEast());
    var bounds = this.getExtendedBounds(mapBounds);

    for (var i = 0, marker; marker = this.markers_[i]; i++) {
        if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
            this.addToClosestCluster_(marker);
        }
    }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
    this.markerClusterer_ = markerClusterer;
    this.map_ = markerClusterer.getMap();
    this.gridSize_ = markerClusterer.getGridSize();
    this.minClusterSize_ = markerClusterer.getMinClusterSize();
    this.averageCenter_ = markerClusterer.isAverageCenter();
    this.center_ = null;
    this.markers_ = [];
    this.bounds_ = null;
    this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
        markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
    if (this.markers_.indexOf) {
        return this.markers_.indexOf(marker) != -1;
    } else {
        for (var i = 0, m; m = this.markers_[i]; i++) {
            if (m == marker) {
                return true;
            }
        }
    }
    return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function(marker) {
    if (this.isMarkerAlreadyAdded(marker)) {
        return false;
    }

    if (!this.center_) {
        this.center_ = marker.getPosition();
        this.calculateBounds_();
    } else {
        if (this.averageCenter_) {
            var l = this.markers_.length + 1;
            var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
            var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
            this.center_ = new google.maps.LatLng(lat, lng);
            this.calculateBounds_();
        }
    }

    marker.isAdded = true;
    this.markers_.push(marker);

    var len = this.markers_.length;
    if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
        // Min cluster size not reached so show the marker.
        marker.setMap(this.map_);
    }

    if (len == this.minClusterSize_) {
        // Hide the markers that were showing.
        for (var i = 0; i < len; i++) {
            this.markers_[i].setMap(null);
        }
    }

    if (len >= this.minClusterSize_) {
        marker.setMap(null);
    }

    this.updateIcon();
    return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function() {
    return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function() {
    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
    var markers = this.getMarkers();
    for (var i = 0, marker; marker = markers[i]; i++) {
        bounds.extend(marker.getPosition());
    }
    return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function() {
    this.clusterIcon_.remove();
    this.markers_.length = 0;
    delete this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {number} The cluster center.
 */
Cluster.prototype.getSize = function() {
    return this.markers_.length;
};


/**
 * Returns the center of the cluster.
 *
 * @return {Array.<google.maps.Marker>} The cluster center.
 */
Cluster.prototype.getMarkers = function() {
    return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function() {
    return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function() {
    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
    return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function() {
    return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function() {
    var zoom = this.map_.getZoom();
    var mz = this.markerClusterer_.getMaxZoom();

    if (mz && zoom > mz) {
        // The zoom is greater than our max zoom so show all the markers in cluster.
        for (var i = 0, marker; marker = this.markers_[i]; i++) {
            marker.setMap(this.map_);
        }
        return;
    }

    if (this.markers_.length < this.minClusterSize_) {
        // Min cluster size not yet reached.
        this.clusterIcon_.hide();
        return;
    }

    var numStyles = this.markerClusterer_.getStyles().length;
    var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
    this.clusterIcon_.setCenter(this.center_);
    this.clusterIcon_.setSums(sums);
    this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

    this.styles_ = styles;
    this.padding_ = opt_padding || 0;
    this.cluster_ = cluster;
    this.center_ = null;
    this.map_ = cluster.getMap();
    this.div_ = null;
    this.sums_ = null;
    this.visible_ = false;

    this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 *
 * @param {google.maps.MouseEvent} event The event to propagate
 */
ClusterIcon.prototype.triggerClusterClick = function(event) {
    var markerClusterer = this.cluster_.getMarkerClusterer();

    // Trigger the clusterclick event.
    google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_, event);

    if (markerClusterer.isZoomOnClick()) {
        // Zoom into the cluster.
        this.map_.fitBounds(this.cluster_.getBounds());
    }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function() {
    this.div_ = document.createElement('DIV');
    if (this.visible_) {
        var pos = this.getPosFromLatLng_(this.center_);
        this.div_.style.cssText = this.createCss(pos);
        this.div_.innerHTML = this.sums_.text;
    }

    var panes = this.getPanes();
    panes.overlayMouseTarget.appendChild(this.div_);

    var that = this;
    var isDragging = false;
    google.maps.event.addDomListener(this.div_, 'click', function(event) {
        // Only perform click when not preceded by a drag
        if (!isDragging) {
            that.triggerClusterClick(event);
        }
    });
    google.maps.event.addDomListener(this.div_, 'mousedown', function() {
        isDragging = false;
    });
    google.maps.event.addDomListener(this.div_, 'mousemove', function() {
        isDragging = true;
    });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
    var pos = this.getProjection().fromLatLngToDivPixel(latlng);

    if (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {
        pos.x -= this.iconAnchor_[0];
        pos.y -= this.iconAnchor_[1];
    } else {
        pos.x -= parseInt(this.width_ / 2, 10);
        pos.y -= parseInt(this.height_ / 2, 10);
    }
    return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function() {
    if (this.visible_) {
        var pos = this.getPosFromLatLng_(this.center_);
        this.div_.style.top = pos.y + 'px';
        this.div_.style.left = pos.x + 'px';
    }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function() {
    if (this.div_) {
        this.div_.style.display = 'none';
    }
    this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function() {
    if (this.div_) {
        var pos = this.getPosFromLatLng_(this.center_);
        this.div_.style.cssText = this.createCss(pos);
        this.div_.style.display = '';
    }
    this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function() {
    this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function() {
    if (this.div_ && this.div_.parentNode) {
        this.hide();
        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
    }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function(sums) {
    this.sums_ = sums;
    this.text_ = sums.text;
    this.index_ = sums.index;
    if (this.div_) {
        this.div_.innerHTML = sums.text;
    }

    this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function() {
    var index = Math.max(0, this.sums_.index - 1);
    index = Math.min(this.styles_.length - 1, index);
    var style = this.styles_[index];
    this.url_ = style['url'];
    this.height_ = style['height'];
    this.width_ = style['width'];
    this.textColor_ = style['textColor'];
    this.anchor_ = style['anchor'];
    this.textSize_ = style['textSize'];
    this.backgroundPosition_ = style['backgroundPosition'];
    this.iconAnchor_ = style['iconAnchor'];
    this.lineHeight_ = style['lineHeight'] || "1em";
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
    this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
    var style = [];
    style.push('background-image:url(' + this.url_ + ');');
    var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
    style.push('background-position:' + backgroundPosition + ';');

    if (typeof this.anchor_ === 'object') {
        if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
            this.anchor_[0] < this.height_) {
            style.push('height:' + (this.height_ - this.anchor_[0]) +
                'px; padding-top:' + this.anchor_[0] + 'px;');
        } else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&
            -this.anchor_[0] < this.height_) {
            style.push('height:' + this.height_ + 'px; line-height:' + this.lineHeight_ +
                'px;');
        } else {
            style.push('height:' + this.height_ + 'px; line-height:' + this.lineHeight_ +
                'px;');
        }
        if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
            this.anchor_[1] < this.width_) {
            style.push('width:' + (this.width_ - this.anchor_[1]) +
                'px; padding-left:' + this.anchor_[1] + 'px;');
        } else {
            style.push('width:' + this.width_ + 'px; text-align:center;');
        }
    } else {
        style.push('height:' + this.height_ + 'px; line-height:' +
            this.lineHeight_ + 'px; width:' + this.width_ + 'px; text-align:center;');
    }

    var txtColor = this.textColor_ ? this.textColor_ : 'black';
    var txtSize = this.textSize_ ? this.textSize_ : 11;

    style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
        pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
        txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
    return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window['MarkerClusterer'] = MarkerClusterer;
MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype['clearMarkers'] =
    MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype['fitMapToMarkers'] =
    MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype['getCalculator'] =
    MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype['getGridSize'] =
    MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype['getExtendedBounds'] =
    MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype['getTotalClusters'] =
    MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype['getTotalMarkers'] =
    MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype['removeMarker'] =
    MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype['removeMarkers'] =
    MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype['resetViewport'] =
    MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype['repaint'] =
    MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype['setCalculator'] =
    MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype['setGridSize'] =
    MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype['setMaxZoom'] =
    MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;

Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
Cluster.prototype['getSize'] = Cluster.prototype.getSize;
Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;

ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;;
﻿/*!
 * jQuery Form Plugin
 * version: 3.51.0-2014.06.20
 * Requires jQuery v1.5 or later
 * Copyright (c) 2014 M. Alsup
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Project repository: https://github.com/malsup/form
 * Dual licensed under the MIT and GPL licenses.
 * https://github.com/malsup/form#copyright-and-license
 */
(function(n){"use strict";typeof define=="function"&&define.amd?define(["jquery"],n):n(typeof jQuery!="undefined"?jQuery:window.Zepto)})(function(n){"use strict";function u(t){var i=t.data;t.isDefaultPrevented()||(t.preventDefault(),n(t.target).ajaxSubmit(i))}function f(t){var r=t.target,u=n(r),f,i,e;if(!u.is("[type=submit],[type=image]")){if(f=u.closest("[type=submit]"),f.length===0)return;r=f[0]}i=this;i.clk=r;r.type=="image"&&(t.offsetX!==undefined?(i.clk_x=t.offsetX,i.clk_y=t.offsetY):typeof n.fn.offset=="function"?(e=u.offset(),i.clk_x=t.pageX-e.left,i.clk_y=t.pageY-e.top):(i.clk_x=t.pageX-r.offsetLeft,i.clk_y=t.pageY-r.offsetTop));setTimeout(function(){i.clk=i.clk_x=i.clk_y=null},100)}function t(){if(n.fn.ajaxSubmit.debug){var t="[jquery.form] "+Array.prototype.join.call(arguments,"");window.console&&window.console.log?window.console.log(t):window.opera&&window.opera.postError&&window.opera.postError(t)}}var i={},r;i.fileapi=n("<input type='file'/>").get(0).files!==undefined;i.formdata=window.FormData!==undefined;r=!!n.fn.prop;n.fn.attr2=function(){if(!r)return this.attr.apply(this,arguments);var n=this.prop.apply(this,arguments);return n&&n.jquery||typeof n=="string"?n:this.attr.apply(this,arguments)};n.fn.ajaxSubmit=function(u){function ot(t){for(var r=n.param(t,u.traditional).split("&"),o=r.length,e=[],f,i=0;i<o;i++)r[i]=r[i].replace(/\+/g," "),f=r[i].split("="),e.push([decodeURIComponent(f[0]),decodeURIComponent(f[1])]);return e}function st(t){for(var f,r,s,o=new FormData,i=0;i<t.length;i++)o.append(t[i].name,t[i].value);if(u.extraData)for(f=ot(u.extraData),i=0;i<f.length;i++)f[i]&&o.append(f[i][0],f[i][1]);return u.data=null,r=n.extend(!0,{},n.ajaxSettings,u,{contentType:!1,processData:!1,cache:!1,type:e||"POST"}),u.uploadProgress&&(r.xhr=function(){var t=n.ajaxSettings.xhr();return t.upload&&t.upload.addEventListener("progress",function(n){var t=0,i=n.loaded||n.position,r=n.total;n.lengthComputable&&(t=Math.ceil(i/r*100));u.uploadProgress(n,i,r,t)},!1),t}),r.data=null,s=r.beforeSend,r.beforeSend=function(n,t){t.data=u.formData?u.formData:o;s&&s.call(this,n,t)},n.ajax(r)}function ft(i){function ot(n){var i=null;try{n.contentWindow&&(i=n.contentWindow.document)}catch(r){t("cannot get iframe.contentWindow document: "+r)}if(i)return i;try{i=n.contentDocument?n.contentDocument:n.document}catch(r){t("cannot get iframe.contentDocument: "+r);i=n.document}return i}function st(){function h(){try{var n=ot(a).readyState;t("state = "+n);n&&n.toLowerCase()=="uninitialized"&&setTimeout(h,50)}catch(i){t("Server abort: ",i," (",i.name,")");b(tt);g&&clearTimeout(g);g=undefined}}var u=f.attr2("target"),s=f.attr2("action"),y=f.attr("enctype")||f.attr("encoding")||"multipart/form-data",r,i,c;l.setAttribute("target",d);(!e||/post/i.test(e))&&l.setAttribute("method","POST");s!=o.url&&l.setAttribute("action",o.url);o.skipEncodingOverride||e&&!/post/i.test(e)||f.attr({encoding:"multipart/form-data",enctype:"multipart/form-data"});o.timeout&&(g=setTimeout(function(){rt=!0;b(ut)},o.timeout));r=[];try{if(o.extraData)for(i in o.extraData)o.extraData.hasOwnProperty(i)&&(n.isPlainObject(o.extraData[i])&&o.extraData[i].hasOwnProperty("name")&&o.extraData[i].hasOwnProperty("value")?r.push(n('<input type="hidden" name="'+o.extraData[i].name+'">').val(o.extraData[i].value).appendTo(l)[0]):r.push(n('<input type="hidden" name="'+i+'">').val(o.extraData[i]).appendTo(l)[0]));o.iframeTarget||v.appendTo("body");a.attachEvent?a.attachEvent("onload",b):a.addEventListener("load",b,!1);setTimeout(h,15);try{l.submit()}catch(p){c=document.createElement("form").submit;c.apply(l)}}finally{l.setAttribute("action",s);l.setAttribute("enctype",y);u?l.setAttribute("target",u):f.removeAttr("target");n(r).remove()}}function b(i){var r,u,w,f,k,d,e,c,l;if(!s.aborted&&!lt){if(h=ot(a),h||(t("cannot access response document"),i=tt),i===ut&&s){s.abort("timeout");y.reject(s,"timeout");return}if(i==tt&&s){s.abort("server abort");y.reject(s,"error","server abort");return}if(h&&h.location.href!=o.iframeSrc||rt){a.detachEvent?a.detachEvent("onload",b):a.removeEventListener("load",b,!1);r="success";try{if(rt)throw"timeout";if(w=o.dataType=="xml"||h.XMLDocument||n.isXMLDoc(h),t("isXml="+w),!w&&window.opera&&(h.body===null||!h.body.innerHTML)&&--ct){t("requeing onLoad callback, DOM not available");setTimeout(b,250);return}f=h.body?h.body:h.documentElement;s.responseText=f?f.innerHTML:null;s.responseXML=h.XMLDocument?h.XMLDocument:h;w&&(o.dataType="xml");s.getResponseHeader=function(n){var t={"content-type":o.dataType};return t[n.toLowerCase()]};f&&(s.status=Number(f.getAttribute("status"))||s.status,s.statusText=f.getAttribute("statusText")||s.statusText);k=(o.dataType||"").toLowerCase();d=/(json|script|text)/.test(k);d||o.textarea?(e=h.getElementsByTagName("textarea")[0],e?(s.responseText=e.value,s.status=Number(e.getAttribute("status"))||s.status,s.statusText=e.getAttribute("statusText")||s.statusText):d&&(c=h.getElementsByTagName("pre")[0],l=h.getElementsByTagName("body")[0],c?s.responseText=c.textContent?c.textContent:c.innerText:l&&(s.responseText=l.textContent?l.textContent:l.innerText))):k=="xml"&&!s.responseXML&&s.responseText&&(s.responseXML=at(s.responseText));try{ht=yt(s,k,o)}catch(nt){r="parsererror";s.error=u=nt||r}}catch(nt){t("error caught: ",nt);r="error";s.error=u=nt||r}s.aborted&&(t("upload aborted"),r=null);s.status&&(r=s.status>=200&&s.status<300||s.status===304?"success":"error");r==="success"?(o.success&&o.success.call(o.context,ht,"success",s),y.resolve(s.responseText,"success",s),p&&n.event.trigger("ajaxSuccess",[s,o])):r&&(u===undefined&&(u=s.statusText),o.error&&o.error.call(o.context,s,r,u),y.reject(s,"error",u),p&&n.event.trigger("ajaxError",[s,o,u]));p&&n.event.trigger("ajaxComplete",[s,o]);p&&!--n.active&&n.event.trigger("ajaxStop");o.complete&&o.complete.call(o.context,s,r);lt=!0;o.timeout&&clearTimeout(g);setTimeout(function(){o.iframeTarget?v.attr("src",o.iframeSrc):v.remove();s.responseXML=null},100)}}}var l=f[0],it,nt,o,p,d,v,a,s,k,w,rt,g,y=n.Deferred(),ut,tt,ft,et,ht,h,ct,lt;if(y.abort=function(n){s.abort(n)},i)for(nt=0;nt<c.length;nt++)it=n(c[nt]),r?it.prop("disabled",!1):it.removeAttr("disabled");if(o=n.extend(!0,{},n.ajaxSettings,u),o.context=o.context||o,d="jqFormIO"+(new Date).getTime(),o.iframeTarget?(v=n(o.iframeTarget),w=v.attr2("name"),w?d=w:v.attr2("name",d)):(v=n('<iframe name="'+d+'" src="'+o.iframeSrc+'" />'),v.css({position:"absolute",top:"-1000px",left:"-1000px"})),a=v[0],s={aborted:0,responseText:null,responseXML:null,status:0,statusText:"n/a",getAllResponseHeaders:function(){},getResponseHeader:function(){},setRequestHeader:function(){},abort:function(i){var r=i==="timeout"?"timeout":"aborted";t("aborting upload... "+r);this.aborted=1;try{a.contentWindow.document.execCommand&&a.contentWindow.document.execCommand("Stop")}catch(u){}v.attr("src",o.iframeSrc);s.error=r;o.error&&o.error.call(o.context,s,r,i);p&&n.event.trigger("ajaxError",[s,o,r]);o.complete&&o.complete.call(o.context,s,r)}},p=o.global,p&&0==n.active++&&n.event.trigger("ajaxStart"),p&&n.event.trigger("ajaxSend",[s,o]),o.beforeSend&&o.beforeSend.call(o.context,s,o)===!1)return o.global&&n.active--,y.reject(),y;if(s.aborted)return y.reject(),y;k=l.clk;k&&(w=k.name,w&&!k.disabled&&(o.extraData=o.extraData||{},o.extraData[w]=k.value,k.type=="image"&&(o.extraData[w+".x"]=l.clk_x,o.extraData[w+".y"]=l.clk_y)));ut=1;tt=2;ft=n("meta[name=csrf-token]").attr("content");et=n("meta[name=csrf-param]").attr("content");et&&ft&&(o.extraData=o.extraData||{},o.extraData[et]=ft);o.forceSync?st():setTimeout(st,10);ct=50;var at=n.parseXML||function(n,t){return window.ActiveXObject?(t=new ActiveXObject("Microsoft.XMLDOM"),t.async="false",t.loadXML(n)):t=(new DOMParser).parseFromString(n,"text/xml"),t&&t.documentElement&&t.documentElement.nodeName!="parsererror"?t:null},vt=n.parseJSON||function(s){return window.eval("("+s+")")},yt=function(t,i,r){var f=t.getResponseHeader("content-type")||"",e=i==="xml"||!i&&f.indexOf("xml")>=0,u=e?t.responseXML:t.responseText;return e&&u.documentElement.nodeName==="parsererror"&&n.error&&n.error("parsererror"),r&&r.dataFilter&&(u=r.dataFilter(u,i)),typeof u=="string"&&(i==="json"||!i&&f.indexOf("json")>=0?u=vt(u):(i==="script"||!i&&f.indexOf("javascript")>=0)&&n.globalEval(u)),u};return y}var e,b,o,f,a,v,c,y,s,l,h,d,g,nt,ut,p,w;if(!this.length)return t("ajaxSubmit: skipping submit process - no element selected"),this;if(f=this,typeof u=="function"?u={success:u}:u===undefined&&(u={}),e=u.type||this.attr2("method"),b=u.url||this.attr2("action"),o=typeof b=="string"?n.trim(b):"",o=o||window.location.href||"",o&&(o=(o.match(/^([^#]+)/)||[])[1]),u=n.extend(!0,{url:o,success:n.ajaxSettings.success,type:e||n.ajaxSettings.type,iframeSrc:/^https/i.test(window.location.href||"")?"javascript:false":"about:blank"},u),a={},this.trigger("form-pre-serialize",[this,u,a]),a.veto)return t("ajaxSubmit: submit vetoed via form-pre-serialize trigger"),this;if(u.beforeSerialize&&u.beforeSerialize(this,u)===!1)return t("ajaxSubmit: submit aborted via beforeSerialize callback"),this;if(v=u.traditional,v===undefined&&(v=n.ajaxSettings.traditional),c=[],s=this.formToArray(u.semantic,c),u.data&&(u.extraData=u.data,y=n.param(u.data,v)),u.beforeSubmit&&u.beforeSubmit(s,this,u)===!1)return t("ajaxSubmit: submit aborted via beforeSubmit callback"),this;if(this.trigger("form-submit-validate",[s,this,u,a]),a.veto)return t("ajaxSubmit: submit vetoed via form-submit-validate trigger"),this;l=n.param(s,v);y&&(l=l?l+"&"+y:y);u.type.toUpperCase()=="GET"?(u.url+=(u.url.indexOf("?")>=0?"&":"?")+l,u.data=null):u.data=l;h=[];u.resetForm&&h.push(function(){f.resetForm()});u.clearForm&&h.push(function(){f.clearForm(u.includeHidden)});!u.dataType&&u.target?(d=u.success||function(){},h.push(function(t){var i=u.replaceTarget?"replaceWith":"html";n(u.target)[i](t).each(d,arguments)})):u.success&&h.push(u.success);u.success=function(n,t,i){for(var e=u.context||this,r=0,o=h.length;r<o;r++)h[r].apply(e,[n,t,i||f,f])};u.error&&(g=u.error,u.error=function(n,t,i){var r=u.context||this;g.apply(r,[n,t,i,f])});u.complete&&(nt=u.complete,u.complete=function(n,t){var i=u.context||this;nt.apply(i,[n,t,f])});var et=n("input[type=file]:enabled",this).filter(function(){return n(this).val()!==""}),tt=et.length>0,it="multipart/form-data",rt=f.attr("enctype")==it||f.attr("encoding")==it,k=i.fileapi&&i.formdata;for(t("fileAPI :"+k),ut=(tt||rt)&&!k,u.iframe!==!1&&(u.iframe||ut)?u.closeKeepAlive?n.get(u.closeKeepAlive,function(){p=ft(s)}):p=ft(s):p=(tt||rt)&&k?st(s):n.ajax(u),f.removeData("jqxhr").data("jqxhr",p),w=0;w<c.length;w++)c[w]=null;return this.trigger("form-submit-notify",[this,u]),this};n.fn.ajaxForm=function(i){if(i=i||{},i.delegation=i.delegation&&n.isFunction(n.fn.on),!i.delegation&&this.length===0){var r={s:this.selector,c:this.context};return!n.isReady&&r.s?(t("DOM not ready, queuing ajaxForm"),n(function(){n(r.s,r.c).ajaxForm(i)}),this):(t("terminating; zero elements found by selector"+(n.isReady?"":" (DOM not ready)")),this)}if(i.delegation){n(document).off("submit.form-plugin",this.selector,u).off("click.form-plugin",this.selector,f).on("submit.form-plugin",this.selector,i,u).on("click.form-plugin",this.selector,i,f);return this}return this.ajaxFormUnbind().bind("submit.form-plugin",i,u).bind("click.form-plugin",i,f)};n.fn.ajaxFormUnbind=function(){return this.unbind("submit.form-plugin click.form-plugin")};n.fn.formToArray=function(t,r){var e=[],l,h,f,c,u,b,k,a,p,v;if(this.length===0)return e;var o=this[0],w=this.attr("id"),s=t?o.getElementsByTagName("*"):o.elements,y;if(s&&!/MSIE [678]/.test(navigator.userAgent)&&(s=n(s).get()),w&&(y=n(':input[form="'+w+'"]').get(),y.length&&(s=(s||[]).concat(y))),!s||!s.length)return e;for(l=0,b=s.length;l<b;l++)if(u=s[l],f=u.name,f&&!u.disabled){if(t&&o.clk&&u.type=="image"){o.clk==u&&(e.push({name:f,value:n(u).val(),type:u.type}),e.push({name:f+".x",value:o.clk_x},{name:f+".y",value:o.clk_y}));continue}if(c=n.fieldValue(u,!0),c&&c.constructor==Array)for(r&&r.push(u),h=0,k=c.length;h<k;h++)e.push({name:f,value:c[h]});else if(i.fileapi&&u.type=="file")if(r&&r.push(u),a=u.files,a.length)for(h=0;h<a.length;h++)e.push({name:f,value:a[h],type:u.type});else e.push({name:f,value:"",type:u.type});else c!==null&&typeof c!="undefined"&&(r&&r.push(u),e.push({name:f,value:c,type:u.type,required:u.required}))}return!t&&o.clk&&(p=n(o.clk),v=p[0],f=v.name,f&&!v.disabled&&v.type=="image"&&(e.push({name:f,value:p.val()}),e.push({name:f+".x",value:o.clk_x},{name:f+".y",value:o.clk_y}))),e};n.fn.formSerialize=function(t){return n.param(this.formToArray(t))};n.fn.fieldSerialize=function(t){var i=[];return this.each(function(){var f=this.name,r,u,e;if(f)if(r=n.fieldValue(this,t),r&&r.constructor==Array)for(u=0,e=r.length;u<e;u++)i.push({name:f,value:r[u]});else r!==null&&typeof r!="undefined"&&i.push({name:this.name,value:r})}),n.param(i)};n.fn.fieldValue=function(t){for(var f,i,r=[],u=0,e=this.length;u<e;u++)(f=this[u],i=n.fieldValue(f,t),i!==null&&typeof i!="undefined"&&(i.constructor!=Array||i.length))&&(i.constructor==Array?n.merge(r,i):r.push(i));return r};n.fieldValue=function(t,i){var a=t.name,u=t.type,h=t.tagName.toLowerCase(),e,o,r,f;if(i===undefined&&(i=!0),i&&(!a||t.disabled||u=="reset"||u=="button"||(u=="checkbox"||u=="radio")&&!t.checked||(u=="submit"||u=="image")&&t.form&&t.form.clk!=t||h=="select"&&t.selectedIndex==-1))return null;if(h=="select"){if(e=t.selectedIndex,e<0)return null;var c=[],l=t.options,s=u=="select-one",v=s?e+1:l.length;for(o=s?e:0;o<v;o++)if(r=l[o],r.selected){if(f=r.value,f||(f=r.attributes&&r.attributes.value&&!r.attributes.value.specified?r.text:r.value),s)return f;c.push(f)}return c}return n(t).val()};n.fn.clearForm=function(t){return this.each(function(){n("input,select,textarea",this).clearFields(t)})};n.fn.clearFields=n.fn.clearInputs=function(t){var i=/^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;return this.each(function(){var r=this.type,u=this.tagName.toLowerCase();i.test(r)||u=="textarea"?this.value="":r=="checkbox"||r=="radio"?this.checked=!1:u=="select"?this.selectedIndex=-1:r=="file"?/MSIE/.test(navigator.userAgent)?n(this).replaceWith(n(this).clone(!0)):n(this).val(""):t&&(t===!0&&/hidden/.test(r)||typeof t=="string"&&n(this).is(t))&&(this.value="")})};n.fn.resetForm=function(){return this.each(function(){typeof this.reset!="function"&&(typeof this.reset!="object"||this.reset.nodeType)||this.reset()})};n.fn.enable=function(n){return n===undefined&&(n=!0),this.each(function(){this.disabled=!n})};n.fn.selected=function(t){return t===undefined&&(t=!0),this.each(function(){var r=this.type,i;r=="checkbox"||r=="radio"?this.checked=t:this.tagName.toLowerCase()=="option"&&(i=n(this).parent("select"),t&&i[0]&&i[0].type=="select-one"&&i.find("option").selected(!1),this.selected=t)})};n.fn.ajaxSubmit.debug=!1});
/*
//# sourceMappingURL=jquery.form.min.js.map
*/;
!function(e){function t(e){var t=new google.maps.LatLng(contactsList[e].lat,contactsList[e].lng),r={center:t,zoom:6};n=new google.maps.Map(document.getElementById("map_canvas_"+e),r);var i=new google.maps.LatLngBounds,a=new google.maps.Marker({position:t,title:"bizcongo",icon:l});i.extend(t),a.setMap(n)}null!=document.getElementById("locationSearch")&&google.maps.event.addDomListener(window,"load",function(){var e=document.getElementById("locationSearch"),t=new google.maps.places.Autocomplete(e,{componentRestrictions:{country:"cd"}});google.maps.event.addListener(t,"place_changed",function(){})}),e(document).ready(function(){function t(){e("#comment-form").length>0&&(e("#comment-form",document).validate({rules:{"files[field_carte_de_felicitation_und_0]":{extension:"jpg|jpeg|gif|png",filesize:1},"field_prenom[und][0][value]":{required:!0},"field_nom[und][0][value]":{required:!0},"field_email_commentaire[und][0][email]":{required:!0,email:!0},"field_message[und][0][value]":{required:!0}},messages:{"files[field_carte_de_felicitation_und_0]":{extension:Drupal.t("Veuillez importer des fichier avec des extensions valide [jpg|jpeg|gif|png]"),filesize:Drupal.t("La taille de fichier dépasse 1M")}}}),e("#comment-form").submit(function(t){e("#g-recaptcha-response".length>0)&&(""==e("#g-recaptcha-response").val()?(!e(".recaptcha-error").length>0&&e(".g-recaptcha").before('<div class="recaptcha-error">'+Drupal.t("Recaptcha est requis")+"</div>"),t.preventDefault()):e(".recaptcha-error").length>0&&e(".recaptcha-error").remove())}),e("#comment-form").click(function(){e("#g-recaptcha-response".length>0)&&""!=e("#g-recaptcha-response").val()&&e(".recaptcha-error").length>0&&e(".recaptcha-error").remove()})),e('form[id^="user-register-form"]',document).length>0&&(e.validator.addMethod("entriprisePhoneRequired",function(t,r){return phone_number=e('form[id^="user-register-form"] input[name="field_phone[und][0][value]"]').val().replace(/\s+/g,""),phone_number.match(/^((\+|00)([0-9]{0,3}))([0-9]{9})$/)},"Veuillez spécifier un numéro de téléphone valide."),e("[data-title]").each(function(t,r){var i=e(r);!1===i.is("[title]")&&i.attr("title","")}),e('form[id^="user-register-form"]',document).validate({rules:{name:{required:!0},mail:{required:!0,email:!0},i_am:{required:!0,entriprisePhoneRequired:!0},abonnement:{required:!0},optin:{required:!0}}}))}if(e(".page-cart-checkout").length>0&&(e("#messages ul #modal-payement-error").length<=0&&e("#messages").hide(),e("#modal-payement-error").length>0&&(e("#modal-payement-error").appendTo("body"),e("#messages #modal-payement-error").remove(),e("#modal-payement-error",document).modal("show"))),e(".spotlight-image-colorbox").length>0&&e(".spotlight-image-colorbox").click(function(){e(this).colorbox({href:e(this).attr("src")})}),e("#uc-cart-checkout-form").length>0&&(e("#uc-cart-checkout-form").validate({rules:{"panes[billing][billing_first_name]":{required:!0},"panes[billing][billing_last_name]":{required:!0},"panes[billing][billing_street1]":{required:!0},"panes[billing][billing_country]":{required:!0},"panes[billing][billing_city]":{required:!0},"panes[billing][billing_zone]":{required:!0},"panes[billing][billing_phone]":{required:!0}}}),e("#uc-cart-checkout-form #edit-cancel").click(function(){e("#edit-panes-billing-billing-first-name").rules("remove","required"),e("#edit-panes-billing-billing-last-name").rules("remove","required"),e("#edit-panes-billing-billing-street1").rules("remove","required"),e("#edit-panes-billing-billing-city").rules("remove","required"),e("#edit-panes-billing-billing-phone").rules("remove","required")})),e("#edit-panes-billing-billing-phone").length>0){var r=e(".form-item-panes-billing-billing-phone").children("label").html();e(".form-item-panes-billing-billing-phone").children("label").empty().html('<span class="form-required" title="Ce champ est requis.">*</span> '+r)}e(".page-node-add .node-form").length>0&&e(".page-node-add .node-form").validate({highlight:function(t){e(t).is("select")&&e(t).parent("div.selector").addClass("error"),e(t).is("textarea")&&e(t).parent("div").addClass("error"),e(t).is('input[type="text"]')&&e(t).addClass("error")},unhighlight:function(t){e(t).is("select")&&e(t).parent("div.selector").removeClass("error"),e(t).is("textarea")&&e(t).parent("div").removeClass("error"),e(t).is('input[type="text"]')&&e(t).removeClass("error")},errorPlacement:function(e,t){"body[und][0][value]"==t.attr("name")?e.insertBefore("textarea#edit-body-und-0-value"):e.insertBefore(t)},rules:{field:{required:!0}}}),e("#naissance-node-form").length>0&&e("#naissance-node-form").validate({rules:{title:{required:!0},"field_marriage_email[und][0][email]":{required:!0,email:!0},"field_marriage_first_name[und][0][value]":{required:!0},"field_nom[und][0][value]":{required:!0},"field_marriage_city[und][0][value]":{required:!0},"field_marriage_country[und][0][value]":{required:!0},"field_marriage_phone[und][0][value]":{required:!0},"field_membre_de_famille[und]":{required:!0},"field_death_last_name[und][0][value]":{required:!0},"field_sexe[und]":{required:!0},"field_company_name[und][0][value]":{required:!0},"field_poids[und][0][value]":{required:!0},"field_bride_mother_name[und][0][value]":{required:!0},"field_bride_father_name[und][0][value]":{required:!0}}}),e("#classified-node-form").length>0&&e("#classified-node-form").validate({highlight:function(t){e(t).is("select")&&e(t).parent("div.selector").addClass("error"),e(t).is("textarea")&&e(t).parent("div").addClass("error"),e(t).is('input[type="text"]')&&e(t).addClass("error")},unhighlight:function(t){e(t).is("select")&&e(t).parent("div.selector").removeClass("error"),e(t).is("textarea")&&e(t).parent("div").removeClass("error"),e(t).is('input[type="text"]')&&e(t).removeClass("error")},errorPlacement:function(e,t){"body[und][0][value]"==t.attr("name")?e.insertBefore("textarea#edit-body-und-0-value"):e.insertBefore(t)},rules:{title:{required:!0},"field_type[und]":{required:!0},"body[und][0][value]":{required:!0},"classified_category[und]":{selected:!0},"field_type[und]":{selected:!0},"field_prix[und][0][value]":{required:!0},"field_devise[und]":{selected:!0},"field_nom_annonceur[und][0][value]":{required:!0},"field_phone[und][0][value]":{phone:!0},"field_email_annonceur[und][0][email]":{email:!0}}}),e("#newsletter-form").length>0&&(e("#newsletter-form #edit-email").defaultify(Drupal.t("Votre email...")),e("#newsletter-form").validate({rules:{email:{required:!0,email:!0}}})),e("#user-pass").length>0&&e("#user-pass").validate({rules:{name:{required:!0}},messages:{name:{required:Drupal.t("Le champ Nom d'utilisateur ou adresse électronique est requis.")}}}),t(),e(document).ajaxComplete(function(){t()}),e("#webform-client-form-15496").length>0&&e("#webform-client-form-15496").validate({highlight:function(t){e("input").not('input[type="file"]').addClass("error"),e(t).is("select")&&e(t).parent("div.selector").addClass("error"),e(t).is('input[type="file"]')&&e(t).parent("div.uploader").addClass("error")},unhighlight:function(t){e(t).is("select")&&e(t).parent("div.selector").removeClass("error"),e(t).is('input[type="file"]')&&e(t).parent("div.uploader").removeClass("error"),e(t).is('input[type="text"]')&&e(t).removeClass("error"),e(t).is('input[type="email"]')&&e(t).removeClass("error")},rules:{"submitted[nom]":{required:!0},"submitted[prenom]":{required:!0},"submitted[sexe]":{required:!0},"submitted[email]":{required:!0,email:!0},"edit-submitted-date-de-naissance":{age:18},"edit-submitted-disponibilite":{required:!0},"files[submitted_cv]":{required:!0,extension:"doc|docx|pdf|txt|rtf|jpg|jpeg|gif|png",filesize:2},"files[submitted_lettre_de_motivation]":{required:!0,extension:"doc|docx|pdf|txt|rtf|jpg|jpeg|gif|png",filesize:2}},messages:{"edit-submitted-date-de-naissance":{age:Drupal.t("L'âge doit être supérieur à 18 ans")},"files[submitted_cv]":{extension:Drupal.t("Veuillez importer des fichier avec des extensions valide [doc|docx|pdf|txt|rtf|jpg|jpeg|gif|png]"),filesize:Drupal.t("La taille de fichier dépasse 2M")},"files[submitted_lettre_de_motivation]":{extension:Drupal.t("Veuillez importer des fichier avec des extensions valide [doc|docx|pdf|txt|rtf|jpg|jpeg|gif|png]"),filesize:Drupal.t("La taille de fichier dépasse 2M")}}}),e(document).on("paste",'input[name="pass[pass1]"], input[name="pass[pass2]"]',function(e){return e.preventDefault(),!1}),e("#user-profile-form").validate({rules:{"pass[pass1]":{required:!0},"pass[pass2]":{required:!0}}}),e("#user-login-form").length>0&&e("#user-login-form").validate({rules:{name:{required:!0},pass:{required:!0}}}),e(".webform-client-form-13553").length>0&&e("#webform-client-form-13553").validate({rules:{"submitted[nom]":{required:!0},"submitted[message]":{required:!0},"submitted[telephone]":{required:!0,phone:!0},"submitted[sujet]":{required:!0},"submitted[mail]":{required:!0,email:!0}}}),e(".node-marriage_announcement-form").length>0&&e(".node-marriage_announcement-form").validate({rules:{title:{required:!0},"field_marriage_first_name[und][0][value]":{required:!0},"field_marriage_email[und][0][email]":{required:!0,email:!0},"field_marriage_address[und][0][value]":{required:!0},"field_marriage_phone[und][0][value]":{required:!0},"field_groom_name[und][0][value]":{required:!0},"field_groom_father_name[und][0][value]":{required:!0},"field_groom_father_name[und][0][value]":{required:!0}}}),e("#contact-site-form").length>0&&e("#contact-site-form").validate({rules:{name:{required:!0},mail:{required:!0,email:!0},subject:{required:!0},message:{required:!0}}}),e("#annuaire-entreprise-advanced-search-form").length>0&&e("#annuaire-entreprise-advanced-search-form").validate({rules:{search:{minlength:2}}});var a=e(".date-disponibilite");if(a.length>0&&(a.datepicker({closeText:Drupal.t("Fermer"),prevText:Drupal.t("Précédent"),nextText:Drupal.t("Suivant"),currentText:Drupal.t("Aujourd'hui"),monthNames:[Drupal.t("Janvier"),Drupal.t("Février"),Drupal.t("Mars"),Drupal.t("Avril"),Drupal.t("Mai"),Drupal.t("Juin"),Drupal.t("Juillet"),Drupal.t("Août"),Drupal.t("Septembre"),Drupal.t("Octobre"),Drupal.t("Novembre"),Drupal.t("Décembre")],monthNamesShort:[Drupal.t("Janv."),Drupal.t("Févr."),Drupal.t("Mars"),Drupal.t("Avril"),Drupal.t("Mai"),Drupal.t("Juin"),Drupal.t("Juil."),Drupal.t("Août"),Drupal.t("Sept."),Drupal.t("Oct."),Drupal.t("Nov."),Drupal.t("Déc.")],dayNames:[Drupal.t("Dimanche"),Drupal.t("Lundi"),Drupal.t("Mardi"),Drupal.t("Mercredi"),Drupal.t("Jeudi"),Drupal.t("Vendredi"),Drupal.t("Samedi")],dayNamesShort:[Drupal.t("Dim."),Drupal.t("Lun."),Drupal.t("Mar."),Drupal.t("Mer."),Drupal.t("Jeu."),Drupal.t("Ven."),Drupal.t("Sam.")],dayNamesMin:[Drupal.t("D"),Drupal.t("L"),Drupal.t("M"),Drupal.t("M"),Drupal.t("J"),Drupal.t("V"),Drupal.t("S")],changeMonth:!0,changeYear:!0,dateFormat:"dd-mm-yy"}),a.change(function(){!function(t,r){for(r=r.split("/"),i=0;3>i;i++)r[i]=parseInt(r[i]);e(t+" div[class*='-day'] select").val(r[0]),e(t+" div[class*='-month'] select").val(r[1]),e(t+" div[class*='-year'] select").val(r[2])}(".date-disponibilite",e(this).val())})),e(".default-visuelle").length>0&&e(".default-visuelle").click(function(){e.colorbox({width:"80%",height:"80%",iframe:!0,href:".default-visuelle"})}),e(".annuaire-entreprise-block").length>0&&(e(".tab-pane",".annuaire-entreprise-block").each(function(){var t=e(this).attr("id"),r=new List(t,{valueNames:["name"]});r.on("searchStart",function(){}),r.on("searchComplete",function(){var r=e(".term-item","#"+t).length,i=r+" "+Drupal.t("résultats");1>=r&&(i=r+" "+Drupal.t("résultat")),e(".count-term","#"+t).html(i),0==r?e(".not-result-annuaire").removeClass("hidden"):11>r?(e(".item-secondaire","#"+t).removeClass("hidden"),e(".not-result-annuaire").hasClass("hidden")||e(".not-result-annuaire").addClass("hidden")):(e(".item-secondaire","#"+t).addClass("hidden"),e(".not-result-annuaire").hasClass("hidden")||e(".not-result-annuaire").addClass("hidden"))})}),e(".annuaire-entreprise-block").length>0)){var n=e(".annuaire-entreprise-block");e(".home-tab li",n).click(function(){e("html, body").animate({scrollTop:e(n).offset().top-130},1e3)})}if(1==e('input[name="approximite_checkbox"]:checked').length&&(e("#a_proximite_checkbox").attr("checked","checked"),e('input[name="location"]').attr("value","").prop("disabled",!0)),e("#enable-geolocation").length>0){e("#enable-geolocation").bootstrapSwitch({onText:"Oui",offText:"Non",onColor:"warning",offColor:"danger"}),e("#enable-geolocation").on("switchChange.bootstrapSwitch",function(t,r){r?e("#a_proximite_checkbox").prop("checked",!1):e("#a_proximite_checkbox").prop("checked",!0),r?navigator.geolocation?navigator.geolocation.getCurrentPosition(function(t){e('input[name="user_latitude"]').val(t.coords.latitude),e('input[name="user_longitude"]').val(t.coords.longitude),e("#annuaire-entreprise-advanced-search-form").submit()},function(){alert("Géolocalisation n'est pas autorisé")}):alert("Géolocalisation n'est pas autorisé"):(e('input[name="user_latitude"]').val(""),e('input[name="user_longitude"]').val(""),e('input[name="proxomity"]').val(""))}),e("#a_proximite_checkbox").parent().find("label").attr("for","a_proximite_checkbox"),e("#a_proximite_checkbox").change(function(){e("#enable-geolocation").bootstrapSwitch("state",this.checked)});var l=e('input[name="proxomity"]').val();Drupal.settings.jsproxomity>0&&(l=Drupal.settings.jsproxomity),e("#slider-range-min").slider({range:"min",value:l,min:0,max:900,slide:function(t,r){e('input[name="proxomity"]').val(r.value),e("#slider-range-value").html(r.value+"KM")}})}if(e(".formulaire-modifiable").length>0&&e(".message-commentaire").length>0&&e(".formulaire-modifiable").change(function(){e(".message-commentaire").text(e(".formulaire-modifiable option:selected").text())}),e("#map-canvas").length>0){var o=null,s=Drupal.settings.mod_bizcongo.icon;new google.maps.InfoWindow,google.maps.event.addDomListener(window,"load",function(){if(null!=Drupal.settings&&null!=Drupal.settings.mod_bizcongo){if(null!=Drupal.settings.mod_bizcongo.lat)var e=parseFloat(Drupal.settings.mod_bizcongo.lat);if(null!=Drupal.settings.mod_bizcongo.lon)var t=parseFloat(Drupal.settings.mod_bizcongo.lon)}var r=new google.maps.LatLng(e,t),i={center:r,zoom:6,scrollwheel:!1};o=new google.maps.Map(document.getElementById("map-canvas"),i);var a=new google.maps.LatLngBounds,n=new google.maps.Marker({position:r,title:"bizcongo",icon:s});a.extend(r),n.setMap(o);var l=Drupal.settings.mod_bizcongo.adresse,d=new google.maps.InfoWindow({content:l});n.addListener("click",function(){d.open(o,n)})})}});var r=decodeURIComponent(window.location.search.substring(1));sURLVariables=r.split("?");for(var i=0;i<sURLVariables.length;i++)sParameterName=sURLVariables[i].split("="),sParameterName=sParameterName[0];if(e("#btn-event").click(function(){e("html, body").animate({scrollTop:e("#comment-form").offset().top-120},2e3)}),"comment"===sParameterName&&e("#btn-event").trigger("click"),e(window).load(function(){e("#product-node-form").length>0&&e("#edit-field-en-promotion-und").length>0&&(e("#edit-field-en-promotion-und").is(":checked")?e("#edit-field-prix-intial").show():e("#edit-field-prix-intial").hide(),e("#edit-field-en-promotion-und").change(function(){e("#edit-field-en-promotion-und").is(":checked")?e("#edit-field-prix-intial").show("slow"):e("#edit-field-prix-intial").hide("slow")})),e(".fiche_product").length>0&&e("#shop_link").click(function(){e("#shop_product_fiche").addClass("hide"),e("#shop_default_content").show()})}),e(".view-id-contacts").length>0){contactsList=void 0!==map_contacts?map_contacts:{},i=0;for(var a=contactsList.length;a>i;i++){var n=null,l="/sites/all/themes/bizcongo/images/map.png";new google.maps.InfoWindow,google.maps.event.addDomListener(window,"load",t(i))}}}(jQuery),jQuery(function(e){e.extend({check:function(){console.log("im form function")},initialize:function(){null!=Drupal.gmap&&setTimeout(function(){var t=window.location.href,r=new URL(t),i=r.searchParams.get("latitude"),a=r.searchParams.get("longitude"),n=Drupal.gmap.getMap("auto1map").map,l=r.searchParams.get("proxomity"),o="";null!=a&&null!=i&&(o=new google.maps.LatLng(i,a),null!=l?(search_area={strokeColor:570425599,strokeOpacity:0,strokeWeight:2,fillOpacity:0,fillColor:570425599,center:new google.maps.LatLng(i,a),radius:1e3*l,map:n},search_area=new google.maps.Circle(search_area),n.fitBounds(search_area.getBounds()),google.maps.event.addListenerOnce(n,"idle",function(){e.each(Drupal.settings.gmap.auto1map.markers,function(e,t){new google.maps.LatLng(t.latitude,t.longitude),console.log(google.maps.geometry.spherical.computeDistanceBetween(t.marker.getPosition(),search_area.getCenter())<=search_area.getRadius()),google.maps.geometry.spherical.computeDistanceBetween(t.marker.getPosition(),search_area.getCenter())<=search_area.getRadius()||(console.log("is not in area"),t.marker.setMap(null))}),e.check()})):(n.setCenter(o),n.setZoom(9)),console.log([]),google.maps.event.addListener(n,"zoom_changed",function(){e.each(Drupal.settings.gmap.auto1map.markers,function(e,t){t.marker.setMap(null)})}))},500)}}),e.initialize()});;
/**
 * @file
 * Adds two new methods to the Infobubble.prototype class.
 */
/*jshint -W069 */

if (typeof InfoBubble === 'function') {
    /* First new method: bubbleBackgroundClassName allows theming of the whole
     popup bubble via css. */
    InfoBubble.prototype.setBubbleBackgroundClassName = function (className) {
        this.contentContainer_.classList.add(className);
    };
    InfoBubble.prototype['setBubbleBackgroundClassName'] =
        InfoBubble.prototype.setBubbleBackgroundClassName;

    /* Second new method: closeImage allows reference to a custom image to
     close the popup window. */
    InfoBubble.prototype.setCloseImage = function (image) {
        this.close_.src = image;
    };
    InfoBubble.prototype['setCloseImage'] =
        InfoBubble.prototype.setCloseImage;

    /* Third new method: closePosition allows you to set the position to something
     other than absolute. */
    InfoBubble.prototype.setClosePosition = function (position) {
        this.close_.style['position'] = position;
    };
    InfoBubble.prototype['setClosePosition'] =
        InfoBubble.prototype.setClosePosition;

    /* Fourth new method: closeWidth allows you to specify a custom close image width */
    InfoBubble.prototype.setCloseWidth = function (width) {
        this.close_.style['width'] = width;
    };
    InfoBubble.prototype['setCloseWidth'] =
        InfoBubble.prototype.setCloseWidth;

    /* Fifth new method: closeHeight allows you to specify a custom close image height */
    InfoBubble.prototype.setCloseHeight = function (height) {
        this.close_.style['height'] = height;
    };
    InfoBubble.prototype['setCloseHeight'] =
        InfoBubble.prototype.setCloseHeight;

    /* Sixth new method: closeBorder allows you to add a border to the close image. */
    InfoBubble.prototype.setCloseBorder = function (border) {
        this.close_.style['border'] = border;
    };
    InfoBubble.prototype['setCloseBorder'] =
        InfoBubble.prototype.setCloseBorder;

    /* Seventh new method: closeZIndex allows you to set a custom zindex for your
     close image. */
    InfoBubble.prototype.setCloseZIndex = function (zIndex) {
        this.close_.style['zIndex'] = zIndex;
    };
    InfoBubble.prototype['setCloseZIndex'] =
        InfoBubble.prototype.setCloseZIndex;

    /* Eighth new method: closeCursor allows you change what your cursor turns
     into on hovering on the close image. */
    InfoBubble.prototype.setCloseCursor = function (cursor) {
        this.close_.style['cursor'] = cursor;
    };
    InfoBubble.prototype['setCloseCursor'] =
        InfoBubble.prototype.setCloseCursor;
}
;
/**
 * @file
 * Drupal to Google Maps API bridge.
 */

/*global jQuery, Drupal, GLatLng, GSmallZoomControl, GLargeMapControl, GMap2 */
/*global GMapTypeControl, GSmallMapControl, G_HYBRID_MAP, G_NORMAL_MAP */
/*global G_PHYSICAL_MAP, G_SATELLITE_MAP, GHierarchicalMapTypeControl */
/*global GKeyboardHandler, GLatLngBounds, GMenuMapTypeControl, GEvent */
/*global GOverviewMapControl, GScaleControl, GUnload */
/*jshint -W069 */

(function () { // BEGIN closure
    var handlers = {};
    var maps = {};
    var ajaxoffset = 0;

    Drupal.gmap = {

        /**
         * Retrieve a map object for use by a non-widget.
         * Use this if you need to be able to fire events against a certain map
         * which you have the mapid for.
         * Be a good GMap citizen! Remember to send change()s after modifying variables!
         */
        getMap: function (mapid) {
            if (maps[mapid]) {
                return maps[mapid];
            }
            else {
                // Perhaps the user passed a widget id instead?
                mapid = mapid.split('-').slice(1, -1).join('-');
                if (maps[mapid]) {
                    return maps[mapid];
                }
            }
            return false;
        },

        unloadMap: function (mapid) {
            delete maps[mapid];
        },

        addHandler: function (handler, callback) {
            if (!handlers[handler]) {
                handlers[handler] = [];
            }
            handlers[handler].push(callback);
        },

        globalChange: function (name, userdata) {
            for (var mapid in Drupal.settings.gmap) {
                if (Drupal.settings.gmap.hasOwnProperty(mapid)) {
                    // Skip maps that are set up but not shown, etc.
                    if (maps[mapid]) {
                        maps[mapid].change(name, -1, userdata);
                    }
                }
            }
        },

        setup: function (settings) {
            var obj = this;

            var initcallback = function (mapid) {
                return (function () {
                    maps[mapid].change("bootstrap_options", -1);
                    maps[mapid].change("boot", -1);
                    maps[mapid].change("init", -1);
                    // Send some changed events to fire up the rest of the initial settings..
                    maps[mapid].change("maptypechange", -1);
                    maps[mapid].change("controltypechange", -1);
                    maps[mapid].change("alignchange", -1);
                    // Set ready to put the event system into action.
                    maps[mapid].ready = true;
                    maps[mapid].change("ready", -1);
                });
            };

            if (settings || (Drupal.settings && Drupal.settings.gmap)) {
                var mapid = obj.id.split('-');
                if (Drupal.settings['gmap_remap_widgets']) {
                    if (Drupal.settings['gmap_remap_widgets'][obj.id]) {
                        jQuery.each(Drupal.settings['gmap_remap_widgets'][obj.id].classes, function () {
                            jQuery(obj).addClass(this);
                        });
                        mapid = Drupal.settings['gmap_remap_widgets'][obj.id].id.split('-');
                    }
                }
                var instanceid = mapid.pop();
                mapid.shift();
                mapid = mapid.join('-');
                var control = instanceid.replace(/\d+$/, '');

                // Lazy init the map object.
                if (!maps[mapid]) {
                    if (settings) {
                        maps[mapid] = new Drupal.gmap.map(settings);
                    }
                    else {
                        maps[mapid] = new Drupal.gmap.map(Drupal.settings.gmap[mapid]);
                    }
                    // Prepare the initialization callback.
                    var callback = initcallback(mapid);
                    setTimeout(callback, 0);
                }

                if (handlers[control]) {
                    for (var i = 0; i < handlers[control].length; i++) {
                        handlers[control][i].call(maps[mapid], obj);
                    }
                }
                else {
                    // Element with wrong class?
                }
            }
        }
    };

    jQuery.fn.createGMap = function (settings, mapid) {
        return this.each(function () {
            if (!mapid) {
                mapid = 'auto' + ajaxoffset + 'ajax';
                ajaxoffset++;
            }
            settings.id = mapid;
            jQuery(this)
                .attr('id', 'gmap-' + mapid + '-gmap0')
                .css('width', settings.width)
                .css('height', settings.height)
                .addClass('gmap-control')
                .addClass('gmap-gmap')
                .addClass('gmap')
                .addClass('gmap-map')
                .addClass('gmap-' + mapid + '-gmap')
                .addClass('gmap-processed')
                .each(function () {
                    Drupal.gmap.setup.call(this, settings);
                });
        });
    };

})(); // END closure

Drupal.gmap.factory = {};

Drupal.gmap.map = function (v) {
    this.vars = v;
    this.map = undefined;
    this.ready = false;
    var _bindings = {};

    /**
     * Register interest in a change.
     */
    this.bind = function (name, callback) {
        if (!_bindings[name]) {
            _bindings[name] = [];
        }
        return _bindings[name].push(callback) - 1;
    };

    /**
     * Change notification.
     * Interested parties can act on changes.
     */
    this.change = function (name, id, userdata) {
        var c;
        if (_bindings[name]) {
            for (c = 0; c < _bindings[name].length; c++) {
                if (c !== id) {
                    _bindings[name][c](userdata);
                }
            }
        }
        if (name !== 'all') {
            this.change('all', -1, name, userdata);
        }
    };

    /**
     * Deferred change notification.
     * This will cause a change notification to be tacked on to the *end* of the event queue.
     */
    this.deferChange = function (name, id, userdata) {
        var obj = this;
        // This will move the function call to the end of the event loop.
        setTimeout(function () {
            obj.change(name, id, userdata);
        }, 0);
    };

    this.getMapTypeName = function (type) {
        if (type == 'map' || type == 'roadmap') return 'Map';
        if (type == 'hybrid') return 'Hybrid';
        if (type == 'physical' || type == 'terrain') return 'Physical';
        if (type == 'satellite') return 'Satellite';
    };

    this.getMapTypeId = function (type) {
        if (type == 'Map' || type == 'Roadmap') return google.maps.MapTypeId.ROADMAP;
        if (type == 'Hybrid') return google.maps.MapTypeId.HYBRID;
        if (type == 'Physical' || type == 'Terrain') return google.maps.MapTypeId.TERRAIN;
        if (type == 'Satellite') return google.maps.MapTypeId.SATELLITE;
    };
};

////////////////////////////////////////
//             Map widget             //
////////////////////////////////////////
Drupal.gmap.addHandler('gmap', function (elem) {
    var obj = this;
    var _ib = {};

    // Respond to incoming zooms
    _ib.zoom = obj.bind("zoom", function (zoom) {
        obj.map.setZoom(obj.vars.zoom);
    });

    // Respond to incoming moves
    _ib.move = obj.bind("move", function () {
        obj.map.panTo(new google.maps.LatLng(obj.vars.latitude, obj.vars.longitude));
    });

    // Respond to incoming width changes.
    _ib.width = obj.bind("widthchange", function (w) {
        obj.map.getDiv().style.width = w;
        google.maps.event.trigger(obj.map);
    });
    // Send out outgoing width changes.
    // N/A
    // Respond to incoming height changes.
    _ib.height = obj.bind("heightchange", function (h) {
        obj.map.getDiv().style.height = h;
        google.maps.event.trigger(obj.map);
    });
    // Send out outgoing height changes.
    // N/A

    // Respond to incoming control type changes.
    _ib.ctc = obj.bind("controltypechange", function () {
        if (obj.vars.controltype === 'Small') {
            obj.map.setOptions({zoomControlOptions: {style: google.maps.ZoomControlStyle.SMALL}});
        }
        else if (obj.vars.controltype === 'Large') {
            obj.map.setOptions({zoomControlOptions: {style: google.maps.ZoomControlStyle.LARGE}});
        }
        // obsolete
        else if (obj.vars.controltype === 'Android') {
            obj.map.setOptions({zoomControlOptions: {style: google.maps.ZoomControlStyle.SMALL}});
        }
    });
    // Send out outgoing control type changes.
    // N/A

    // Respond to incoming map type changes.
    _ib.mtc = obj.bind("maptypechange", function () {
        obj.map.setMapTypeId(obj.getMapTypeId(obj.vars.maptype));
    });
    // Send out outgoing map type changes.
    // N/A

    obj.bind("bootstrap_options", function () {
        // Bootup options.
        var opts = {}; // Object literal google.maps.MapOptions
        obj.opts = opts;

        // Disable default UI for custom options
        opts.disableDefaultUI = true;

        // Set draggable property
        if (obj.vars.behavior.nodrag) {
            opts.draggable = false;
        }
        else if (obj.vars.behavior.nokeyboard) {
            opts.keyboardShortcuts = false;
        }

        // Set default map type (set to road map if nothing selected)
        switch (obj.vars.maptype) {
            case 'Hybrid':
                opts.mapTypeId = google.maps.MapTypeId.HYBRID;
                break;
            case 'Physical':
                opts.mapTypeId = google.maps.MapTypeId.TERRAIN;
                break;
            case 'Satellite':
                opts.mapTypeId = google.maps.MapTypeId.SATELLITE;
                break;
            /* falls through */
            case 'Map':
            /* falls through */
            default:
                opts.mapTypeId = google.maps.MapTypeId.ROADMAP;
                break;
        }

        // Null out the enabled types.
        opts.mapTypeIds = [];

        if (obj.vars.baselayers.Map) {
            opts.mapTypeIds.push(google.maps.MapTypeId.ROADMAP);
        }
        if (obj.vars.baselayers.Hybrid) {
            opts.mapTypeIds.push(google.maps.MapTypeId.HYBRID);
        }
        if (obj.vars.baselayers.Physical) {
            opts.mapTypeIds.push(google.maps.MapTypeId.TERRAIN);
        }
        if (obj.vars.baselayers.Satellite) {
            opts.mapTypeIds.push(google.maps.MapTypeId.SATELLITE);
        }

        if (obj.vars.draggableCursor) {
            opts.draggableCursor = obj.vars.draggableCursor;
        }
        if (obj.vars.draggingCursor) {
            opts.draggingCursor = obj.vars.draggingCursor;
        }
        if (obj.vars.backgroundColor) {
            opts.backgroundColor = obj.vars.backgroundColor;
        }

        // Map type control
        opts.mapTypeControl = true;
        opts.mapTypeControlOptions = {};
        if (obj.vars.mtc === 'standard') {
            opts.mapTypeControlOptions.style = google.maps.MapTypeControlStyle.DEFAULT;
        }
        else if (obj.vars.mtc === 'horiz') {
            opts.mapTypeControlOptions.style = google.maps.MapTypeControlStyle.HORIZONTAL_BAR;
        }
        else if (obj.vars.mtc === 'menu') {
            opts.mapTypeControlOptions.style = google.maps.MapTypeControlStyle.DROPDOWN_MENU;
        }
        else if (obj.vars.mtc === 'none') {
            opts.mapTypeControl = false;
        }

        // Navigation control type
        if (obj.vars.controltype !== 'None') {
            opts.zoomControl = true;
        }
        if (obj.vars.pancontrol) {
            opts.panControl = true;
        }
        if (obj.vars.streetviewcontrol) {
            opts.streetViewControl = true;
        }
        if (obj.vars.controltype === 'Small') {
            obj.zoomControlOptions = {style: google.maps.ZoomControlStyle.SMALL};
        }
        else if (obj.vars.controltype === 'Large') {
            obj.zoomControlOptions = {style: google.maps.ZoomControlStyle.LARGE};
        }


        // Set scale control visibility
        opts.scaleControl = obj.vars.behavior.scale;

        // Scroll wheel control
        if (obj.vars.behavior.nomousezoom) {
            opts.scrollwheel = false;
        }
        // Disable double-click zoom
        if (obj.vars.behavior.nocontzoom) {
            opts.disableDoubleClickZoom = true;
        }
        // Overview Map
        if (obj.vars.behavior.overview) {
            opts.overviewMapControl = true;
            opts.overviewMapControlOptions = {opened: true};
        }

        // Map styles.
        if (obj.vars.mapstyles) {
            obj.opts.styles = obj.vars.mapstyles;
        }
    });

    obj.bind("boot", function () {
        obj.map = new google.maps.Map(elem, obj.opts);
        //console.log(obj.map);
    });

    obj.bind("init", function () {
        var map = obj.map;

        // Not implemented in API v3
        // if (obj.vars.behavior.overview) {
        //   map.addControl(new GOverviewMapControl());
        // }
        // if (obj.vars.behavior.googlebar) {
        //   map.enableGoogleBar();
        // }

        if (obj.vars.extent) {
            var c = obj.vars.extent;
            var extent = new google.maps.LatLngBounds(new google.maps.LatLng(c[0][0], c[0][1]), new google.maps.LatLng(c[1][0], c[1][1]));
            obj.vars.latitude = extent.getCenter().lat();
            obj.vars.longitude = extent.getCenter().lng();
            obj.vars.zoom = map.getBoundsZoomLevel(extent);
        }
        if (obj.vars.behavior.collapsehack) {
            // Modify collapsable fieldsets to make maps check dom state when the resize handle
            // is clicked. This may not necessarily be the correct thing to do in all themes,
            // hence it being a behavior.
            setTimeout(function () {
                var r = function () {
                    var coord = map.getCenter();
                    google.maps.event.trigger(map, "resize");
                    map.setCenter(new google.maps.LatLng(coord.lat(), coord.lng()), obj.vars.zoom);
                };
                jQuery(elem).parents('fieldset.collapsible').children('legend').children('a').click(r);
                jQuery('.vertical-tab-button', jQuery(elem).parents('.vertical-tabs')).children('a').click(r);
                jQuery(window).bind('hashchange', r);
                // Would be nice, but doesn't work.
                //$(elem).parents('fieldset.collapsible').children('.fieldset-wrapper').scroll(r);
            }, 0);
        }
        map.setCenter(new google.maps.LatLng(obj.vars.latitude, obj.vars.longitude));
        map.setZoom(obj.vars.zoom);

        // Send out outgoing zooms
        google.maps.event.addListener(map, "zoom_changed", function () {
            obj.vars.zoom = map.getZoom();
            obj.change("zoom", _ib.zoom);
        });

        // Send out outgoing moves
        google.maps.event.addListener(map, "center_changed", function () {
            var coord = map.getCenter();
            obj.vars.latitude = coord.lat();
            obj.vars.longitude = coord.lng();
            obj.change("move", _ib.move);
        });

        // Send out outgoing map type changes.
        google.maps.event.addListener(map, "maptypeid_changed", function () {
            // If the map isn't ready yet, ignore it.
            if (obj.ready) {
                obj.vars.maptype = obj.getMapTypeName(map.getMapTypeId());
                obj.change("maptypechange", _ib.mtc);
            }
        });

        /*
         google.maps.event.addListener(map, 'click', function(event) {
         alert(Drupal.gmap.getIcon("big blue", 0));
         var marker = new google.maps.Marker({
         position: event.latLng,
         map: map
         });
         google.maps.event.addListener(marker, 'click', function() {
         marker.setMap(null);
         });
         });
         */
    });
});

////////////////////////////////////////
//            Zoom widget             //
////////////////////////////////////////
Drupal.gmap.addHandler('zoom', function (elem) {
    var obj = this;
    // Respond to incoming zooms
    var binding = obj.bind("zoom", function () {
        elem.value = obj.vars.zoom;
    });
    // Send out outgoing zooms
    jQuery(elem).change(function () {
        obj.vars.zoom = parseInt(elem.value, 10);
        obj.change("zoom", binding);
    });
});

////////////////////////////////////////
//          Latitude widget           //
////////////////////////////////////////
Drupal.gmap.addHandler('latitude', function (elem) {
//  var obj = this;
//  // Respond to incoming movements.
//  var binding = obj.bind("move", function () {
//    elem.value = '' + obj.vars.latitude;
//  });
//  // Send out outgoing movements.
//  $(elem).change(function () {
//    obj.vars.latitude = Number(this.value);
//    obj.change("move", binding);
//  });
});

////////////////////////////////////////
//         Longitude widget           //
////////////////////////////////////////
Drupal.gmap.addHandler('longitude', function (elem) {
//  var obj = this;
//  // Respond to incoming movements.
//  var binding = obj.bind("move", function () {
//    elem.value = '' + obj.vars.longitude;
//  });
//  // Send out outgoing movements.
//  $(elem).change(function () {
//    obj.vars.longitude = Number(this.value);
//    obj.change("move", binding);
//  });
});

////////////////////////////////////////
//          Latlon widget             //
////////////////////////////////////////
Drupal.gmap.addHandler('latlon', function (elem) {
    var obj = this;
    // Respond to incoming movements.
    var binding = obj.bind("move", function () {
        elem.value = '' + obj.vars.latitude + ',' + obj.vars.longitude;
    });
    // Send out outgoing movements.
    jQuery(elem).change(function () {
        var t = this.value.split(',');
        obj.vars.latitude = Number(t[0]);
        obj.vars.longitude = Number(t[1]);
        obj.change("move", binding);
    });
});

////////////////////////////////////////
//          Maptype widget            //
////////////////////////////////////////
Drupal.gmap.addHandler('maptype', function (elem) {
    var obj = this;
    // Respond to incoming movements.
    var binding = obj.bind("maptypechange", function () {
        elem.value = obj.vars.maptype;
    });
    // Send out outgoing movements.
    jQuery(elem).change(function () {
        obj.vars.maptype = elem.value;
        obj.change("maptypechange", binding);
    });
});

(function () { // BEGIN CLOSURE
    var re = /([0-9.]+)\s*(em|ex|px|in|cm|mm|pt|pc|%)/;
    var normalize = function (str) {
        var ar;
        if ((ar = re.exec(str.toLowerCase()))) {
            return ar[1] + ar[2];
        }
        return null;
    };

    ////////////////////////////////////////
    //           Width widget             //
    ////////////////////////////////////////
    Drupal.gmap.addHandler('width', function (elem) {
        var obj = this;
        // Respond to incoming width changes.
        var binding = obj.bind("widthchange", function (w) {
            elem.value = normalize(w);
        });
        // Send out outgoing width changes.
        jQuery(elem).change(function () {
            var n;
            if ((n = normalize(elem.value))) {
                elem.value = n;
                obj.change('widthchange', binding, n);
            }
        });
        obj.bind('init', function () {
            jQuery(elem).change();
        });
    });

    ////////////////////////////////////////
    //           Height widget            //
    ////////////////////////////////////////
    Drupal.gmap.addHandler('height', function (elem) {
        var obj = this;
        // Respond to incoming height changes.
        var binding = obj.bind("heightchange", function (h) {
            elem.value = normalize(h);
        });
        // Send out outgoing height changes.
        jQuery(elem).change(function () {
            var n;
            if ((n = normalize(elem.value))) {
                elem.value = n;
                obj.change('heightchange', binding, n);
            }
        });
        obj.bind('init', function () {
            jQuery(elem).change();
        });
    });
})(); // END CLOSURE

////////////////////////////////////////
//        Control type widget         //
////////////////////////////////////////
Drupal.gmap.addHandler('controltype', function (elem) {
    var obj = this;
    // Respond to incoming height changes.
    var binding = obj.bind("controltypechange", function () {
        elem.value = obj.vars.controltype;
    });
    // Send out outgoing height changes.
    jQuery(elem).change(function () {
        obj.vars.controltype = elem.value;
        obj.change("controltypechange", binding);
    });
});

// // Map cleanup.
// if (Drupal.jsEnabled) {
//   $(document).unload(GUnload);
// }

Drupal.behaviors.GMap = {
    attach: function (context, settings) {
        if (Drupal.settings && Drupal.settings['gmap_remap_widgets']) {
            jQuery.each(Drupal.settings['gmap_remap_widgets'], function (key, val) {
                jQuery('#' + key).addClass('gmap-control');
            });
        }
        jQuery('.gmap-gmap:not(.gmap-processed)', context).addClass('gmap-processed').each(function () {
            Drupal.gmap.setup.call(this);
        });
        jQuery('.gmap-control:not(.gmap-processed)', context).addClass('gmap-processed').each(function () {
            Drupal.gmap.setup.call(this);
        });
    },
    detach: function (context, settings) {
        jQuery('.gmap-processed', context).each(function (element) {
            //find mapid
            var id = jQuery(this).attr('id');
            var mapid = id.split('-', 2);

            //unload map
            Drupal.gmap.unloadMap(mapid[1]);
        }).removeClass('gmap-processed');
    }
};
;
/**
 * @file
 * GIcon manager for GMap.
 * Required for markers to operate properly.
 */

/*global jQuery, Drupal, GIcon, GPoint, GSize, G_DEFAULT_ICON */

/**
 * Get the GIcon corresponding to a setname / sequence.
 * There is only one GIcon for each slot in the sequence.
 * The marker set wraps around when reaching the end of the sequence.
 * @@@ TODO: Move this directly into the preparemarker event binding.
 */
Drupal.gmap.getIcon = function (setname, sequence) {
    var othimg = ['printImage', 'mozPrintImage', 'printShadow', 'transparent'];
    // If no setname, return google's default icon.
    if (!setname) {
        return;
    }
    if (!this.gicons) {
        this.gicons = {};
    }
    if (!this.gshadows) {
        this.gshadows = {};
    }

    // If no sequence, synthesise one.
    if (!sequence) {
        // @TODO make this per-map.
        if (!this.sequences) {
            this.sequences = {};
        }
        if (!this.sequences[setname]) {
            this.sequences[setname] = -1;
        }
        this.sequences[setname]++;
        sequence = this.sequences[setname];
    }

    if (!this.gicons[setname]) {
        if (!Drupal.gmap.icons[setname]) {
            alert('Request for invalid marker set ' + setname + '!');
        }
        this.gicons[setname] = [];
        this.gshadows[setname] = [];
        var q = Drupal.gmap.icons[setname];
        var p, t;
        for (var i = 0; i < q.sequence.length; i++) {
            /*
             t = new GIcon();
             p = q.path;
             t.image = p + q.sequence[i].f;
             if (q.shadow.f !== '') {
             t.shadow = p + q.shadow.f;
             t.shadowSize = new GSize(q.shadow.w, q.shadow.h);
             }
             t.iconSize = new GSize(q.sequence[i].w, q.sequence[i].h);
             t.iconAnchor = new GPoint(q.anchorX, q.anchorY);
             t.infoWindowAnchor = new GPoint(q.infoX, q.infoY);
             */
            p = Drupal.settings.basePath + q.path;
            t = new google.maps.MarkerImage(p + q.sequence[i].f,
                new google.maps.Size(q.sequence[i].w, q.sequence[i].h),
                null,
                new google.maps.Point(q.anchorX, q.anchorY)
            );
            // Only set scaledSize if the scale variable makes sense as a divisor
            if (q.scale > 1) {
              t.scaledSize = new google.maps.Size(q.sequence[i].w/q.scale, q.sequence[i].h/q.scale);
            }
            if (q.shadow.f !== '') {
                this.gshadows[setname][i] = new google.maps.MarkerImage(p + q.shadow.f,
                    new google.maps.Size(q.shadow.w, q.shadow.h),
                    null,
                    new google.maps.Point(q.anchorX, q.anchorY)
                );
            }
            else {
                this.gshadows[setname][i] = null;
            }

            for (var j = 0; j < othimg.length; j++) {
                if (q[othimg[j]] !== '') {
                    t[othimg[j]] = p + q[othimg[j]];
                }
            }
            // @@@ imageMap?
            this.gicons[setname][i] = t;
        }
        delete Drupal.gmap.icons[setname];
    }
    // TODO: Random, other cycle methods.
    return this.gicons[setname][sequence % this.gicons[setname].length];
};

Drupal.gmap.getShadow = function (setname, sequence) {
    if (this.gshadows) return this.gshadows[setname][sequence % this.gicons[setname].length];
};

/**
 * JSON callback to set up the icon defs.
 * When doing the JSON call, the data comes back in a packed format.
 * We need to expand it and file it away in a more useful format.
 */
Drupal.gmap.iconSetup = function () {
    Drupal.gmap.icons = {};
    var m = Drupal.gmap.icondata;
    var filef, filew, fileh, files;
    for (var path in m) {
        if (m.hasOwnProperty(path)) {
            // Reconstitute files array
            filef = m[path].f;
            filew = Drupal.gmap.expandArray(m[path].w, filef.length);
            fileh = Drupal.gmap.expandArray(m[path].h, filef.length);
            files = [];
            for (var i = 0; i < filef.length; i++) {
                files[i] = {f: filef[i], w: filew[i], h: fileh[i]};
            }

            for (var ini in m[path].i) {
                if (m[path].i.hasOwnProperty(ini)) {
                    jQuery.extend(Drupal.gmap.icons, Drupal.gmap.expandIconDef(m[path].i[ini], path, files));
                }
            }
        }
    }
};

/**
 * Expand a compressed array.
 * This will pad arr up to len using the last value of the old array.
 */
Drupal.gmap.expandArray = function (arr, len) {
    var d = arr[0];
    for (var i = 0; i < len; i++) {
        if (!arr[i]) {
            arr[i] = d;
        }
        else {
            d = arr[i];
        }
    }
    return arr;
};

/**
 * Expand icon definition.
 * This helper function is the reverse of the packer function found in
 * gmap_markerinfo.inc.
 */
Drupal.gmap.expandIconDef = function (c, path, files) {
    var decomp = ['key', 'name', 'sequence', 'anchorX', 'anchorY', 'infoX',
        'infoY', 'scale', 'shadow', 'printImage', 'mozPrintImage', 'printShadow',
        'transparent'];
    var fallback = ['', '', [], 0, 0, 0, 0, 0, {f: '', h: 0, w: 0}, '', '', '', ''];
    var imagerep = ['shadow', 'printImage', 'mozPrintImage', 'printShadow',
        'transparent'];
    var defaults = {};
    var sets = [];
    var i, j;
    // Part 1: Defaults / Markersets
    // Expand arrays and fill in missing ones with fallbacks
    for (i = 0; i < decomp.length; i++) {
        if (!c[0][i]) {
            c[0][i] = [ fallback[i] ];
        }
        c[0][i] = Drupal.gmap.expandArray(c[0][i], c[0][0].length);
    }
    for (i = 0; i < c[0][0].length; i++) {
        for (j = 0; j < decomp.length; j++) {
            if (i === 0) {
                defaults[decomp[j]] = c[0][j][i];
            }
            else {
                if (!sets[i - 1]) {
                    sets[i - 1] = {};
                }
                sets[i - 1][decomp[j]] = c[0][j][i];
            }
        }
    }
    for (i = 0; i < sets.length; i++) {
        for (j = 0; j < decomp.length; j++) {
            if (sets[i][decomp[j]] === fallback[j]) {
                sets[i][decomp[j]] = defaults[decomp[j]];
            }
        }
    }
    var icons = {};
    for (i = 0; i < sets.length; i++) {
        var key = sets[i].key;
        icons[key] = sets[i];
        icons[key].path = path;
        delete icons[key].key;
        delete sets[i];
        for (j = 0; j < icons[key].sequence.length; j++) {
            icons[key].sequence[j] = files[icons[key].sequence[j]];
        }
        for (j = 0; j < imagerep.length; j++) {
            if (typeof(icons[key][imagerep[j]]) === 'number') {
                icons[key][imagerep[j]] = files[icons[key][imagerep[j]]];
            }
        }
    }
    return icons;
};

/**
 * We attach ourselves if we find a map somewhere needing markers.
 * Note: Since we broadcast our ready event to all maps, it doesn't
 * matter which one we attached to!
 */
Drupal.gmap.addHandler('gmap', function (elem) {
    var obj = this;

    obj.bind('init', function () {
        // Only expand once.
        if (!Drupal.gmap.icons) {
            Drupal.gmap.iconSetup();
        }
    });

    obj.bind('ready', function () {
        // Compatibility event.
        if (Drupal.gmap.icondata) {
            obj.deferChange('iconsready', -1);
        }
    });

    // Provide icons to markers.
    obj.bind('preparemarker', function (marker) {
      if (!obj.vars.behavior.customicons || (marker.markername && !marker.opts.icon)) {
        marker.opts.icon = Drupal.gmap.getIcon(marker.markername, marker.offset);
        marker.opts.shadow = Drupal.gmap.getShadow(marker.markername, marker.offset);
      }
    });
});
;
/**
 * @file
 * Common marker routines.
 */

/*global jQuery, Drupal, GEvent, GInfoWindowTab, GLatLng, GLatLngBounds */

Drupal.gmap.addHandler('gmap', function (elem) {
    var obj = this;
    var infowindow;

    if (obj.vars.styleBubble && obj.vars.styleBubble.enableBubbleStyle == 1) {
        infowindow = new InfoBubble(obj.vars.styleBubble.styleBubbleOptions);
    }
    else {
        infowindow = new google.maps.InfoWindow();
    }

    obj.bind('init', function () {
        if (obj.vars.behavior.autozoom) {
            obj.bounds = new google.maps.LatLngBounds();
        }
    });

    obj.bind('addmarker', function (marker) {
        marker.opts.position = new google.maps.LatLng(marker.latitude, marker.longitude);
        marker.opts.map = obj.map;
        var m = Drupal.gmap.factory.marker(marker.opts);
        marker.marker = m;
        google.maps.event.addListener(m, 'click', function () {
            obj.change('clickmarker', -1, marker);
        });
        if (obj.vars.behavior.extramarkerevents) {
            google.maps.event.addListener(m, 'mouseover', function () {
                obj.change('mouseovermarker', -1, marker);
            });
            google.maps.event.addListener(m, 'mouseout', function () {
                obj.change('mouseoutmarker', -1, marker);
            });
            google.maps.event.addListener(m, 'dblclick', function () {
                obj.change('dblclickmarker', -1, marker);
            });
        }
        /**
         * Perform a synthetic marker click on this marker on load.
         */
        if (marker.autoclick || (marker.options && marker.options.autoclick)) {
            obj.deferChange('clickmarker', -1, marker);
        }
        if (obj.vars.behavior.autozoom) {
            obj.bounds.extend(new google.maps.LatLng(marker.latitude, marker.longitude));
        }
    });

    // Default marker actions.
    obj.bind('clickmarker', function (marker) {
        // Close infowindow if open to prevent multiple windows
        if (infowindow !== null) {
            infowindow.close();
        }
        if (marker.text) {
            infowindow.setContent(marker.text);
            infowindow.open(obj.map, marker.marker);
        }
        // Info Window Query / Info Window Offset
        else if (marker.iwq || (obj.vars.iwq && typeof marker.iwo != 'undefined')) {
            var iwq, iwo;
            if (obj.vars.iwq) {
                iwq = obj.vars.iwq;
            }
            if (marker.iwq) {
                iwq = marker.iwq;
            }
            iwo = 0;
            if (marker.iwo) {
                iwo = marker.iwo;
            }
            // Create a container to store the cloned DOM elements.
            var el = document.createElement('div');
            // Clone the matched object, run through the clone, stripping off ids, and move the clone into the container.
            jQuery(iwq).eq(iwo).clone(false).find('*').removeAttr('id').appendTo(jQuery(el));
            infowindow.setContent(el);
            infowindow.open(obj.map, marker.marker);
        }
        // AJAX content
        else if (marker.rmt) {
            //Immediately add a 'loading' bubble on click while we wait for AJAX
            infowindow.setContent('<div class="gmap-marker-rmt-loading throbber">Loading</div>');
            infowindow.open(obj.map, marker.marker);

            var uri = marker.rmt;
            // If there was a callback, prefix that.
            // (If there wasn't, marker.rmt was the FULL path.)
            if (obj.vars.rmtcallback) {
                uri = Drupal.absoluteUrl(obj.vars.rmtcallback + '/' + marker.rmt);
            }
            // @Bevan: I think it makes more sense to do it in this order.
            // @Bevan: I don't like your choice of variable btw, seems to me like
            // @Bevan: it belongs in the map object, or at *least* somewhere in
            // @Bevan: the gmap settings proper...
            //if (!marker.text && Drupal.settings.loadingImage) {
            //  marker.marker.openInfoWindowHtml(Drupal.settings.loadingImage);
            //}
            jQuery.get(uri, {}, function (data) {
                infowindow.setContent(data);
                infowindow.open(obj.map, marker.marker);
            });
        }
        // Tabbed content
        else if (marker.tabs) {
            var data = "";
            //tabs in an infowindow is no longer supported in API ver3.
            for (var m in marker.tabs) {
                data += marker.tabs[m];
            }
            infowindow.setContent(data);
            infowindow.open(obj.map, marker.marker);
        }
        // No content -- marker is a link
        else if (marker.link) {
            open(marker.link, '_self');
        }
    });

    obj.bind('markersready', function () {
        // If we are autozooming, set the map center at this time.
        if (obj.vars.behavior.autozoom) {
            if (!obj.bounds.isEmpty()) {
                obj.map.fitBounds(obj.bounds);
                var listener = google.maps.event.addListener(obj.map, "idle", function () {
                    if (obj.vars.maxzoom) {
                        var maxzoom = parseInt(obj.vars.maxzoom);
                        if (obj.map.getZoom() > maxzoom) obj.map.setZoom(maxzoom);
                        google.maps.event.removeListener(listener);
                    }
                });
            }
        }
    });

    obj.bind('clearmarkers', function () {
        // Reset bounds if autozooming
        // @@@ Perhaps we should have a bounds for both markers and shapes?
        if (obj.vars.behavior.autozoom) {
            obj.bounds = new google.maps.LatLngBounds();
        }
    });

    Drupal.gmap.getInfoWindow = function () {
        return infowindow;
    };

    // @@@ TODO: Some sort of bounds handling for deletemarker? We'd have to walk the whole thing to figure out the new bounds...
});
;
/**
 * @file
 * Common marker highlighting routines.
 */

/**
 * Highlights marker on rollover.
 * Removes highlight on previous marker.
 *
 * Creates a "circle" at the given point
 * Circle is global variable as there is only one highlighted marker at a time
 * and we want to remove the previously placed polygon before placing a new one.
 *
 * Original code "Google Maps JavaScript API Example"
 * JN201304:
 *    converted rpolygons to circles (not using the shapes.js API, should we be?)
 *    move marker highlight events to custom handler here, to handle radius in pixels (note behavior.radiusInMeters to skip geodesic calcs)
 *    removed google.events and moved events to gmaps binds
 *    added overlay object for creating a shape based on pixels instead of meters (seems to be the use case?)
 *    added gmaps binds for marker higlights, and general highlights.
 * JN201305 refactored to use a single overlay.  move functions from draw method to solve zoom problem, and multiple
 *    highlights problem.
 *
 * You can add highlights to a map with:
 *    obj.change('highlightAdd',-1, {latitude:#, longitude:#} );
 * You can highlight a marker with:
 *    obj.change('markerHighlight',-1, marker);
 *      marker: that marker object used when creating the marker.  It can have options set at marker.highlight
 *
 * A Highlight object has to have either a <LatLng>Position or a <Number>latitude and <Number>longitude
 * Note the new highlight options = {
 *       radius: 10, // radius in pixels
 *       color: '#777777',
 *       weight: 2,
 *       opacity: 0.7,
 *       behavior: {
 *          draggable: false,
 *          editable: false,
 *       }
 *       opts: { actual google.maps.Circle opts can be put here for super custom cases }
 * }
 */

Drupal.gmap.factory.highlight = function (options) {
    /** @note it could be argued that we use the shapes library to create a circle,
     * but this requires the shapes library be loaded and it would make all highlights
     * repond to shapes events.
     */
    return new google.maps.Circle(options);
};

Drupal.gmap.addHandler('gmap', function (elem) {
    var obj = this;
    obj.highlights = {};

    /**
     * This is a single overlay that can hold multiple highlight.
     * All highlight shapes will be creted in this overlay, and use
     * it to translate pixel dimensions to meters.
     */
    var highlightOverlay = function () {
        this.highlights = []; // this will hold all of the highlights that we created, in case we need to recalculate/deactivate them
    };
    highlightOverlay.prototype = new google.maps.OverlayView();

    // overlay method for when you .setMap( some map );
    highlightOverlay.prototype.onAdd = function (map) {
    };
    // overlay method for when you .setMap(null);
    highlightOverlay.prototype.onRemove = function () {
        // we have to recalculate radii for all shapes
        var self = this;
        jQuery.each(this.highlights, function (index, highlight) {
            if (highlight.shape.getMap()) { // don't calculate if we don't have a map.
                self.calculateHighlight(highlight); //recalculate all of those radii
            }
        });
    };

    // overlay method executed on any map change methods (zoom/move)
    highlightOverlay.prototype.draw = function () {
        // we have to recalculate radii for all shapes
        var self = this;
        jQuery.each(this.highlights, function (index, highlight) {
            if (highlight.shape.getMap()) { // don't calculate if we don't have a map.
                self.deactivateHighlight(highlight); //recalculate all of those radii
            }
        });
    };

    highlightOverlay.prototype.configHighlight = function (highlight) {
        if (!highlight.opts) {
            highlight.opts = {};
        } // sanity
        if (!highlight.behavior) {
            highlight.behavior = {};
        } // sanity
        if (!highlight.position) {
            highlight.position = new google.maps.LatLng(highlight.latitude, highlight.longitude);
        } // if you have a pos already then use it, otherwise gimme a lat/lon

        jQuery.each({ // collect the options from either the highlight.opts object, from the passed target value, as a behavior or a defaultVal value.
            radius: {target: 'radius', defaultVal: 10}, // radius in pixels
            strokeColor: {target: 'border', defaultVal: '#777777'},
            strokeWeight: {target: 'weight', defaultVal: 2},
            strokeOpacity: {target: 'opacity', defaultVal: 0.7},
            fillColor: {target: 'color', defaultVal: '#777777'},
            fillOpacity: {target: 'opacity', defaultVal: 0.7},
            draggable: {behavior: 'draggable', defaultVal: false},
            editable: {behavior: 'editable', defaultVal: false}
        }, function (key, config) {
            if (highlight.opts[key]) { // options was passed in
                return true;
            }
            else if (config.target && highlight[ config.target ]) { // highight[target] can give us a setting
                highlight.opts[key] = highlight[ config.target ];
            }
            else if (config.behavior && highlight.behavior && highlight.behavior[ config.behavior ]) { // value is a behaviour, should it be enabled?
                highlight.opts[key] = highlight.behavior[ config.behavior ];
            }
            else if (config.defaultVal) { // defaultVal value
                highlight.opts[key] = config.defaultVal;
            }
        });

        highlight.opts.center = highlight.position;
        // note that there is no opts.map, unless you passed one in.  maybe we should make sure that you didn't?

        // add this highlight to our list, so that we can draw it in the draw method (which will also redraw it after map change events.
        this.highlights.push(highlight);
    };
    // determine how big the circle should be in meters (as we were likely passed pixels).  This radius changes on zoom and move events.
    highlightOverlay.prototype.calculateHighlight = function (highlight) { // this nees a better name

        if (highlight.behavior.radiusInMeters) {
            highligh.opts.radiusInMeters = highlight.opts.radius;
        }
        else {
            var mapZoom = this.map.getZoom();
            var projection = this.getProjection();
            var center = projection.fromLatLngToDivPixel(highlight.opts.center, mapZoom);
            var radius = highlight.opts.radius;
            var radial = projection.fromDivPixelToLatLng(new google.maps.Point(center.x, center.y + radius), mapZoom); // find a point that is the radius distance away in pixels from the ccenter point.
            highlight.opts.radiusInMeters = google.maps.geometry.spherical.computeDistanceBetween(highlight.opts.center, radial);
        }

        if (highlight.shape) {
            highlight.shape.setOptions(highlight.opts);
            // we can use this if we don't care about other options changing : highlight.shape.setRadius(highlight.opts.radiusInMeters)
        }
        else {
            highlight.shape = Drupal.gmap.factory.highlight(jQuery.extend({}, highlight.opts, {radius: highlight.opts.radiusInMeters})); // only pass radiusinmeters to g.m.circle.  We keep the pixel radius in case we need to calculate again after a zoom
        }
    };
    highlightOverlay.prototype.activateHighlight = function (highlight) {
        if (!highlight.shape) {
            this.configHighlight(highlight);
            this.calculateHighlight(highlight);
        }
        highlight.shape.setMap(this.map);
    };
    highlightOverlay.prototype.deactivateHighlight = function (highlight) {
        if (highlight.shape) {
            highlight.shape.setMap(null);
        }
    };
    highlightOverlay.prototype.updateHighlight = function (highlight) {
        if (highlight.shape) {
            this.configHighlight(highlight);
            this.calculateHighlight(highlight);
        }
    };

    // prepare a single highlight overlay to be used for all highlights
    obj.bind('init', function (highlight) {
        obj.highlightOverlay = new highlightOverlay(obj.map);
        obj.highlightOverlay.setMap(obj.map); // this will trigger the onAdd() method, and the first draw()
    });

    // set and remove map highlights
    obj.bind('highlightAdd', function (highlight) { // if you activate an activated highlight, nothing happens.
        obj.highlightOverlay.activateHighlight(highlight);
    });
    obj.bind('highlightRemove', function (highlight) {
        obj.highlightOverlay.deactivateHighlight(highlight);
    });
    obj.bind('highlightUpdate', function (highlight) {
        obj.highlightOverlay.updateHighlight(highlight);
    });

    // Marker specific highlight events:
    var highlightedMarkers = []; // remember markers that have been highlighted. so that we can un-highlight them all at one.  The defaultVal behaviour is to allow only 1 marker highlighted at any time.
    obj.bind('markerHighlight', function (marker) {
        highlightedMarkers.push(marker);

        // If the highlight arg option is used in views highlight the marker.
        if (!marker.highlight) {
            marker.highlight = {};
        }
        if (!marker.highlight.color && obj.vars.styles.highlight_color) {
            marker.highlight.color = '#' + obj.vars.styles.highlight_color;
        }
        marker.highlight.position = marker.marker.getPosition();
        obj.change('highlightAdd', -1, marker.highlight);
    });
    obj.bind('markerUnHighlight', function (marker) {
        if (marker.highlight) {
            obj.change('highlightRemove', -1, marker.highlight);
            delete marker.highlight;
        }
    });
    obj.bind('markerUnHighlightActive', function () {
        var marker;
        while (!!(marker = highlightedMarkers.pop())) {
            obj.change('highlightRemove', -1, marker);
        }
    });

    /**
     * Marker Binds
     *
     * Marker highlight code has been moved to this file from the marker.js
     *
     * Note that we rely on the obj.vars.behavior.highlight var to
     * decide if should highlight markers on events.
     * This decision could be made as an outer if conditional, instead
     * of repeated inside each bind, but this arrangement allows for
     * the behaviour to change, at a small cost.
     */
    obj.bind('addmarker', function (marker) {
        if (obj.vars.behavior.highlight) {
            google.maps.event.addListener(marker.marker, 'mouseover', function () {
                obj.change('markerHighlight', -1, marker);
            });
            google.maps.event.addListener(marker.marker, 'mouseout', function () {
                obj.change('markerUnHighlight', -1, marker);
            });
            google.maps.event.addListener(marker.marker, 'mouseout', function () {
                obj.change('markerUnHighlight', -1, marker);
            });
        }
        // If the highlight arg option is used in views highlight the marker.
        if (marker.opts.highlight == 1) {
            obj.change('markerHighlight', -1, marker);
        }
    });

// Originally I moved mouse highlights to the extra event binds before I realized that there is likely a usecase for highlights without enabling extra events
//   obj.bind('mouseovermarker', function(marker) {
//     if (obj.vars.behavior.highlight && marker) {
//       obj.change('markerHighlight',-1,marker);
//     }
//   });
//   obj.bind('mouseoutmarker', function(marker) {
//     if (obj.vars.behavior.highlight && marker) {
//       obj.change('markerUnHighlight',-1,marker);
//     }
//   });

});
;
/**
 * @file
 * GPolyLine / GPolygon manager
 */

/*global Drupal, GLatLng, GPoint */

Drupal.gmap.map.prototype.poly = {};

/**
 * Distance in pixels between 2 points.
 */
Drupal.gmap.map.prototype.poly.distance = function (point1, point2) {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};

/**
 * Circle -- Following projection.
 */
Drupal.gmap.map.prototype.poly.computeCircle = function (obj, center, point2) {
    var numSides = 36;
    var sideInc = 10; // 360 / 20 = 18 degrees
    var convFactor = Math.PI / 180;
    var points = [];
    var radius = obj.poly.distance(center, point2);
    // 36 sided poly ~= circle
    for (var i = 0; i <= numSides; i++) {
        var rad = i * sideInc * convFactor;
        var x = center.x + radius * Math.cos(rad);
        var y = center.y + radius * Math.sin(rad);
        //points.push(obj.map.getCurrentMapType().getProjection().fromPixelToLatLng(new GPoint(x,y),obj.map.getZoom()));
        points.push(new GPoint(x, y));
    }
    return points;
};

Drupal.gmap.map.prototype.poly.calcPolyPoints = function (center, radM, numPoints, sAngle) {
    if (!numPoints) {
        numPoints = 32;
    }
    if (!sAngle) {
        sAngle = 0;
    }

    var d2r = Math.PI / 180.0;
    var r2d = 180.0 / Math.PI;
    var angleRad = sAngle * d2r;
    // earth semi major axis is about 6378137 m
    var latScale = radM / 6378137 * r2d;
    var lngScale = latScale / Math.cos(center.latRadians());

    var angInc = 2 * Math.PI / numPoints;
    var points = [];
    for (var i = 0; i < numPoints; i++) {
        var lat = parseFloat(center.lat()) + latScale * Math.sin(angleRad);
        var lng = parseFloat(center.lng()) + lngScale * Math.cos(angleRad);
        points.push(new GLatLng(lat, lng));
        angleRad += angInc;
    }

    // close the shape and return it
    points.push(points[0]);
    return points;
};
;
